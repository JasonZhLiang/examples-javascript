// Inspired by: http://enterprisejquery.com/2010/10/how-good-c-habits-can-encourage-bad-javascript-habits-part-1/
// Requires that jquery has been loaded as well...
// The variable that will contain the AB Test data retrieved from S3.
var abTestData;

(function(brainCloudManager, undefined)
{
    var _sendQueue = [];
    var _inProgressQueue = [];
    var _abTestingId = -1;
    var _sessionId = "";
    var _packetId = -1;
    var _loader = null;
    var _eventCallback = null;
    var _rewardCallback = null;
    var _errorCallback = null;
    var _jsonedQueue = "";

    var _appId = "";
    var _secret = "";
    var _serverUrl = "https://sharedprod.braincloudservers.com";
    var _dispatcherUrl = _serverUrl + "/dispatcherv2";
    var _fileUploadUrl = _serverUrl + "/uploader";
    var _appVersion = "";
    var _debugEnabled = false;

    var _useJQuery = true;
    var _requestInProgress = false;

    var _statusCodeCache = 403;
    var _reasonCodeCache = 40304;
    var _statusMessageCache = "No session";

    //kill switch
    var _killSwitchThreshold = 11;
    var _killSwitchEngaged = false;
    var _killSwitchErrorCount = 0;
    var _killSwitchService = "";
    var _killSwitchOperation = "";

    var _isInitialized = false;
    var _isAuthenticated = false;

    brainCloudManager.initialize = function(appId, secret, appVersion)
    {
        _appId = appId;
        _secret = secret;
        _appVersion = appVersion;
        _isInitialized = true;
    };

    brainCloudManager.setServerUrl = function(serverUrl)
    {
        _serverUrl = serverUrl;
        while (_serverUrl.length > 0 && _serverUrl.charAt(_serverUrl.length - 1) == '/')
        {
            _serverUrl = _serverUrl.substring(0, _serverUrl.length - 1);
        }
        _dispatcherUrl = _serverUrl + "/dispatcherv2";
        _fileUploadUrl = _serverUrl + "/uploader";
    };

    brainCloudManager.getDispatcherUrl = function()
    {
        return _dispatcherUrl;
    };

    brainCloudManager.getFileUploadUrl = function()
    {
        return _fileUploadUrl;
    };

    brainCloudManager.setABTestingId = function(abTestingId)
    {
        _abTestingId = abTestingId;
    };

    brainCloudManager.getABTestingId = function()
    {
        return _abTestingId;
    };

    brainCloudManager.getSessionId = function()
    {
        return _sessionId;
    };

    brainCloudManager.setSessionId = function(sessionId)
    {
        _sessionId = sessionId;
    };

    brainCloudManager.getSecret = function()
    {
        return _secret;
    };

    brainCloudManager.setSecret = function(secret)
    {
        _secret = secret;
    };

    /**
     * @deprecated Use getAppVersion() instead - Removal after September 1 2017
     */
    brainCloudManager.getGameVersion = function()
    {
        return _appVersion;
    };

    /**
     * @deprecated Use getAppVersion() instead - Removal after September 1 2017
     */
    brainCloudManager.getVersion = function()
    {
        return _appVersion;
    };

    brainCloudManager.getAppVersion = function()
    {
        return _appVersion;
    };

    /**
     * @deprecated Use setAppVersion() instead - Removal after September 1 2017
     */
    brainCloudManager.setGameVersion = function(appVersion)
    {
        _appVersion = appVersion;
    };

    /**
     * @deprecated Use setAppVersion() instead - Removal after September 1 2017
     */
    brainCloudManager.setVersion = function(appVersion)
    {
        _appVersion = appVersion;
    };

    brainCloudManager.setAppVersion = function(appVersion)
    {
        _appVersion = appVersion;
    };

    /**
     * @deprecated Use getAppId() instead - Removal after September 1 2017
     */
    brainCloudManager.getGameId = function()
    {
        return _appId;
    };

    brainCloudManager.getAppId = function()
    {
        return _appId;
    };


    /**
     * @deprecated Use setAppId() instead - Removal after September 1 2017
     */
    brainCloudManager.setGameId = function(appId)
    {
        _appId = appId;
    };

    brainCloudManager.setAppId = function(appId)
    {
        _appId = appId;
    };

    brainCloudManager.registerEventCallback = function(eventCallback)
    {
        _eventCallback = eventCallback;
    };

    brainCloudManager.deregisterEventCallback = function()
    {
        _eventCallback = null;
    };

    brainCloudManager.registerRewardCallback = function(rewardCallback)
    {
        _rewardCallback = rewardCallback;
    };

    brainCloudManager.deregisterRewardCallback = function()
    {
        _rewardCallback = null;
    };

    brainCloudManager.setErrorCallback = function(errorCallback)
    {
        _errorCallback = errorCallback;
    };

    brainCloudManager.setDebugEnabled = function(debugEnabled)
    {
        _debugEnabled = debugEnabled;
    };

    brainCloudManager.useJQuery = function(value)
    {
        _useJQuery = value;
    };

    brainCloudManager.isInitialized = function()
    {
        return _isInitialized;
    };

    brainCloudManager.isAuthenticated = function()
    {
        return _isAuthenticated;
    };

    brainCloudManager.setAuthenticated = function()
    {
        _isAuthenticated = true;
    };

    function debugLog(msg, isError)
    {
        if(_debugEnabled)
        {
            if(isError)
                console.error(msg);
            else
                console.log(msg);
        }
    }

    brainCloudManager.sendRequest = function(request)
    {
        debugLog("SendRequest: " + JSON.stringify(request));

        _sendQueue.push(request);
        if (!_requestInProgress)
        {
            processQueue();
        }
    };

    brainCloudManager.resetCommunication = function()
    {
        _sendQueue = [];
        _inProgressQueue = [];
        _sessionId = "";
        _isAuthenticated = false;
        _requestInProgress = false;
        brainCloudClient.authentication.profileId = "";
        resetErrorCache();
    };

    function resetErrorCache()
    {
        _statusCodeCache = 403;
        _reasonCodeCache = 40304;
        _statusMessageCache = "No session";
    }

    function updateKillSwitch(service, operation, statusCode)
    {
        if (statusCode == brainCloudClient.statusCodes.CLIENT_NETWORK_ERROR) return;

		if (_killSwitchService.length === 0)
		{
			_killSwitchService = service;
			_killSwitchOperation = operation;
			_killSwitchErrorCount++;
		}
		else if (service === _killSwitchService && operation === _killSwitchOperation)
			_killSwitchErrorCount++;

		if (!_killSwitchEngaged && _killSwitchErrorCount >= _killSwitchThreshold)
		{
			_killSwitchEngaged = true;
			debugLog("Client disabled due to repeated errors from a single API call: " + service + " | " + operation);
		}
    }

    function resetKillSwitch()
    {
        _killSwitchErrorCount = 0;
        _killSwitchService = "";
        _killSwitchOperation = "";
    }

    //Handle response bundles with HTTP 200 response
    function handleSuccessResponse(response)
    {
        var messages = response["responses"];

        if (_debugEnabled)
        {
            for (var c = 0; c < messages.length; ++c)
            {
                if (messages[c].status == 200)
                {
                    debugLog("Response(" + messages[c].status + "): " +
                        JSON.stringify(messages[c]));
                }
                else
                {
                    debugLog("Response(" + messages[c].status + "): " +
                        JSON.stringify(messages[c]), true);
                }
            }
        }

        for (var c = 0; c < _inProgressQueue.length && c < messages.length; ++c)
        {
            callback = _inProgressQueue[c].callback;

            if (callback)
            {
                callback(messages[c]);
            }

            if (_inProgressQueue[c] != null && _errorCallback && essages[c].status != 200)
            {
                _errorCallback(messages[c]);
            }

            if (_inProgressQueue[c] == null) return; //comms was reset

            if (messages[c].status == 200)
            {
                resetKillSwitch();

                var data = messages[c].data;

                if (_inProgressQueue[c].service == "playerState" &&
                    (_inProgressQueue[c].operation == "LOGOUT" || _inProgressQueue[c].operation == "FULL_RESET"))
                {
                    _isAuthenticated = false;
                    _sessionId = "";
                    brainCloudClient.authentication.profileId = "";
                }
                else if (_inProgressQueue[c].operation == "AUTHENTICATE")
                {
                    _isAuthenticated = true;
                    if(data.hasOwnProperty("maxKillCount"))
                        _killSwitchThreshold = data.maxKillCount;
                    resetErrorCache();
                }

                if (_rewardCallback)
                {
                    var rewards = null;
                    if (_inProgressQueue[c].service &&
                        _inProgressQueue[c].operation)
                    {
                        if (_inProgressQueue[c].service == "authenticationV2" &&
                            _inProgressQueue[c].operation == "AUTHENTICATE")
                        {
                            resetErrorCache();
                            if (data.rewards && data.rewards.rewards)
                            {
                                rewards = data.rewards;
                            }
                        }
                        else if ((_inProgressQueue[c].service == "playerStatistics" && _inProgressQueue[c].operation == "UPDATE") ||
                            (_inProgressQueue[c].service == "playerStatisticsEvent" && (_inProgressQueue[c].operation == "TRIGGER" || _inProgressQueue[c].operation ==
                                "TRIGGER_MULTIPLE")))
                        {
                            if (data.rewards)
                            {
                                rewards = data;
                            }
                        }

                        if (rewards)
                        {
                            _rewardCallback(rewards);
                        }
                    }
                }
            }
            else
            {
                var statusCode = messages[c].status;
                var resonCode = messages[c].reason_code;

                if (resonCode === 40303 ||
                    resonCode === 40304 ||
                    resonCode === 40356)
                {
                    _isAuthenticated = false;
                    _sessionID = "";

                    // cache error if session related
                    _statusCodeCache = statusCode;
                    _reasonCodeCache = resonCode;
                    _statusMessageCache = messages[c].status_message;
                }

                updateKillSwitch(_inProgressQueue[c].service, _inProgressQueue[c].operation, statusCode)
            }

            var events = response["events"];
            if (events && _eventCallback)
            {
                for (var c = 0; c < events.length; ++c)
                {
                    var eventsJson = {
                        events: events
                    };
                    _eventCallback(eventsJson);
                }
            }
        }
    }

    function fakeErrorResponse(statusCode, reasonCode, message)
    {
        var responses = [_inProgressQueue.length];

        var response = {};
        response.status = statusCode;
        response.reason_code = reasonCode;
        response.status_message = message;
        response.severity = "ERROR";

        for (var i = 0; i < _inProgressQueue.length; i++)
        {
            responses[i] = response;
        }

        handleSuccessResponse(
        {
            "responses": responses
        });
    }

    function setHeader(xhr)
    {
        var sig = CryptoJS.MD5(_jsonedQueue + _secret);
        xhr.setRequestHeader('X-SIG', sig);
    }

    function processQueue()
    {
        if (_sendQueue.length > 0)
        {
            _inProgressQueue = [];
            var itemsProcessed;
            for (itemsProcessed = 0; itemsProcessed < _sendQueue.length; ++itemsProcessed)
            {
                var message = _sendQueue[itemsProcessed];
                if (message.operation == "END_BUNDLE_MARKER")
                {
                    if (_inProgressQueue.length == 0)
                    {
                        // ignore bundle markers at the beginning of the bundle
                        continue;
                    }
                    else
                    {
                        // end the message bundle
                        ++itemsProcessed;
                        break;
                    }
                }
                _inProgressQueue.push(message);
            }
            _sendQueue.splice(0, itemsProcessed);
            if (_inProgressQueue.length <= 0)
            {
                return;
            }

            _jsonedQueue = JSON.stringify(
            {
                messages: _inProgressQueue,
                gameId: _appId,
                sessionId: _sessionId,
                packetId: _packetId++
            });

            if(_killSwitchEngaged)
            {
                fakeErrorResponse(brainCloudClient.statusCodes.CLIENT_NETWORK_ERROR,
                    brainCloudClient.reasonCodes.CLIENT_DISABLED,
                    "Client disabled due to repeated errors from a single API call");
                return;
            }

            if (!_isAuthenticated)
            {
                var isAuth = false;
                for (i = 0; i < _inProgressQueue.length; i++)
                {
                    if (_inProgressQueue[i].operation == "AUTHENTICATE" || _inProgressQueue[i].operation == "RESET_EMAIL_PASSWORD")
                    {
                        isAuth = true;
                        break;
                    }
                }
                if (!isAuth)
                {
                    fakeErrorResponse(_statusCodeCache, _reasonCodeCache, _statusMessageCache);
                    return;
                }
            }

            if (_useJQuery)
            {
                _requestInProgress = true;
                _loader = jQuery.ajax(
                {
                    timeout: 15000,
                    url: _dispatcherUrl,
                    type: "POST",
                    contentType: "application/json",
                    dataType: "json",
                    beforeSend: setHeader,
                    data: _jsonedQueue
                }).done(function(response)
                {
                    handleSuccessResponse(response);
                }).fail(
                    function(jqXhr, textStatus, errorThrown)
                    {
                        debugLog("Failed: " + jqXhr + ", " +
                            textStatus + ", " + errorThrown, true);

                        if ((_errorCallback != undefined) &&
                            (typeof _errorCallback == 'function'))
                        {
                            _errorCallback(errorThrown);
                        }
                    }).always(function(jqXhr, textStatus, errorThrown)
                {
                    //console.log("Complete: " + jqXhr + ", " + textStatus + ", " + errorThrown);
                    _loader = null;
                    _requestInProgress = false;
                    // Now call processQueue again if there is more data...
                    processQueue();
                });
            }
            else
            { // don't use jquery for the request
                _requestInProgress = true;
                var xmlhttp;
                if (window.XMLHttpRequest)
                {
                    // code for IE7+, Firefox, Chrome, Opera, Safari
                    xmlhttp = new XMLHttpRequest();
                }
                else
                {
                    // code for IE6, IE5
                    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                }

                xmlhttp.onreadystatechange = function()
                {
                    if (xmlhttp.readyState == XMLHttpRequest.DONE)
                    {
                        debugLog("response status : " + xmlhttp.status);
                        debugLog("response : " + xmlhttp.responseText);

                        if (xmlhttp.status == 200)
                        {
                            var response = JSON.parse(xmlhttp.responseText);
                            handleSuccessResponse(response);
                        }
                        else
                        {
                            try
                            {
                                var errorResponse = JSON
                                    .parse(xmlhttp.responseText);
                                if (errorResponse["reason_code"])
                                {
                                    reasonCode = errorResponse["reason_code"];
                                }
                                if (errorResponse["status_message"])
                                {
                                    statusMessage = errorResponse["status_message"];
                                }
                                else
                                {
                                    statusMessage = xmlhttp.responseText;
                                }

                            }
                            catch (e)
                            {
                                reasonCode = 0;
                                statusMessage = xmlhttp.responseText;
                            }

                            // TODO: New error handling will split out the parts... for now
                            // just send back the response text.
                            var errorMessage = xmlhttp.responseText;
                            debugLog("Failed", true);

                            if ((_errorCallback != undefined) &&
                                (typeof _errorCallback == 'function'))
                            {
                                _errorCallback(errorMessage);
                            }
                        }
                    }

                    _requestInProgress = false;
                    processQueue();
                }; // end inner function

                xmlhttp.timeout = 15000; //millis
                xmlhttp.open("POST", _dispatcherUrl, true);
                xmlhttp.setRequestHeader("Content-type", "application/json");
                var sig = CryptoJS.MD5(_jsonedQueue + _secret);
                xmlhttp.setRequestHeader("X-SIG", sig);
                xmlhttp.send(_jsonedQueue);
            }
        }
    }
}(window.brainCloudManager = window.brainCloudManager ||
{}));

var brainCloudClient = function(undefined)
{

    var exports = {};

    // private...
    exports.sendRequest = function(serviceRequest)
    {
        brainCloudManager.sendRequest(serviceRequest);
    };

    return exports;

}(window.brainCloudClient = window.brainCloudClient ||
{});

// See the singleton pattern here:
// https://code.google.com/p/jslibs/wiki/JavascriptTips#Singleton_pattern
function BrainCloudAuthentication()
{

    // Singleton
    if (arguments.callee._bcAuthenticationInstance)
        return arguments.callee._bcAuthenticationInstance;

    arguments.callee._bcAuthentication = this;

    this.initialize = function(in_profileId, in_anonymousId) {

    };
}
//----------------------------------------------------
// brainCloud client source code
// Copyright 2016 bitHeads, inc.
//----------------------------------------------------

brainCloudClient.version = "3.5.2";
brainCloudClient.countryCode;
brainCloudClient.languageCode;

/**
 * Initializes the brainCloud client with your app information. This method
 * must be called before any API method is invoked.
 *
 * @param {string}
 *            appId - The app id
 * @param {string}
 *            secret - The app secret
 * @param {string}
 *            version - The app version (e.g. "1.0.0").
 */
brainCloudClient.initialize = function(appId, secret, appVersion) {
    function isBlank(str) {
        return (!str || /^\s*$/.test(str));
    };

    var error = null;
    if (isBlank(secret))
        error = "secret was null or empty";
    else if (isBlank(appId))
        error = "appId was null or empty";
    else if (isBlank(appVersion))
        error = "appVersion was null or empty";
    if (error != null) {
        console.log("ERROR | Failed to initialize brainCloud - " + error);
        return;
    }

    brainCloudManager.initialize(appId, secret, appVersion);
};

/**
 * Initializes the identity service with the most recently
 * used profile id and saved anonymous installation id
 *
 * @param profileId The id of the profile id that was most recently used by the app (on this device)
 * @param anonymousId  The anonymous installation id that was generated for this device
 */
brainCloudClient.initializeIdentity = function(profileId, anonymousId) {
    brainCloudClient.authentication.initialize(profileId, anonymousId);
};

/**
 * Sets the brainCloud server URL. Developers should not need to change this
 * value.
 *
 * @param serverUrl
 *            {string} - The server URL e.g. "https://sharedprod.braincloudservers.com"
 */
brainCloudClient.setServerUrl = function(serverUrl) {
    brainCloudManager.setServerUrl(serverUrl);
};

/**
 * Returns the session id if a connection with brainCloud has been established.
 *
 * @return {string} - The brainCloud session id.
 */
brainCloudClient.getSessionId = function() {
    return brainCloudManager.getSessionId();
};

/**
 * Sets a callback handler for any out of band messages that come from
 * brainCloud (essentially any message sent from brainCloud that wasn't in
 * direct response to a client request).
 *
 * @param eventCallback
 *            {function} eventCallback is a function which takes a json object as it's only parameter
 *
 * where jsonEvents looks like the following:
 * {
 *   "events": [{
 *      "fromPlayerId": "178ed06a-d575-4591-8970-e23a5d35f9df",
 *      "eventId": 3967,
 *      "createdAt": 1441742105908,
 *      "gameId": "10170",
 *      "toPlayerId": "178ed06a-d575-4591-8970-e23a5d35f9df",
 *      "eventType": "test",
 *      "eventData": {"testData": 117}
 *    }],
 *    ]
 *  }
 *
 * @see brainCloudClient.events
 */
brainCloudClient.registerEventCallback = function(eventCallback) {
    brainCloudManager.registerEventCallback(eventCallback);
};

/**
 * Deregisters the event callback.
 */
brainCloudClient.deregisterEventCallback = function() {
    brainCloudManager.deregisterEventCallback();
};

/**
 * Sets a reward handler for any api call results that return rewards.
 *
 * @param in_rewardCallback The reward callback handler.
 * @see The brainCloud apidocs site for more information on the return JSON
 */
brainCloudClient.registerRewardCallback = function(rewardCallback) {
    brainCloudManager.registerRewardCallback(rewardCallback);
};

/**
 * Deregisters the reward callback
 */
brainCloudClient.deregisterRewardCallback = function() {
    brainCloudManager.deregisterRewardCallback();
};

/**
 * Sets a callback handler for any error messages that come from brainCloud.
 * This will include any networking errors as well as requests from the client
 * which do not register a callback handler.
 *
 * @param errorCallback
 *            {function} - The error callback
 */
brainCloudClient.setErrorCallback = function(errorCallback) {
    brainCloudManager.setErrorCallback(errorCallback);
};

/**
 * Turns on/off debugging. This will write all requests/responses
 * to the javascript console log.
 *
 * @param debugEnabled
 *            {boolean} - True to enable debugging, false otherwise.
 */
brainCloudClient.enableLogging = function(enableLogging) {
    brainCloudManager.setDebugEnabled(enableLogging);
};

// deprecated
brainCloudClient.setDebugEnabled = function(debugEnabled) {
    brainCloudManager.setDebugEnabled(debugEnabled);
};

/**
 * Set this flag to use (or not use) jquery as the underlying
 * mechanism to execute http calls. By default, this is true.
 *
 * @param useJQuery
 * {boolean} - True to use JQuery, false otherwise.
 */
brainCloudClient.useJQuery = function(value) {
    brainCloudManager.useJQuery(value);
};

/**
 * Returns whether the client is initialized.
 * @return True if initialized, false otherwise.
 */
brainCloudClient.isInitialized = function() {
    return brainCloudManager.isInitialized();
};

/**
 * Returns whether the client is authenticated with the brainCloud server.
 * @return True if authenticated, false otherwise.
 */
brainCloudClient.isAuthenticated = function() {
    return brainCloudManager.isAuthenticated();
};

brainCloudClient.resetCommunication = function() {
    brainCloudManager.resetCommunication();
};

/**
 * Inserts a marker which will tell the brainCloud comms layer
 * to close the message bundle off at this point. Any messages queued
 * before this method was called will likely be bundled together in
 * the next send to the server.
 *
 * To ensure that only a single message is sent to the server you would
 * do something like this:
 *
 * InsertEndOfMessageBundleMarker()
 * SomeApiCall()
 * InsertEndOfMessageBundleMarker()
 *
 */
brainCloudClient.insertEndOfMessageBundleMarker = function() {
    var message = {
        "operation": "END_BUNDLE_MARKER"
    };
    brainCloudManager.sendRequest(message);
};

/**
 * Sets the country code sent to brainCloud when a user authenticates.
 * Will override any auto detected country.
 * @param countryCode ISO 3166-1 two-letter country code
 */
brainCloudClient.overrideCountryCode = function(countryCode) {
    brainCloudClient.countryCode = countryCode;
}

/**
 * Sets the language code sent to brainCloud when a user authenticates.
 * If the language is set to a non-ISO 639-1 standard value the app default will be used instead.
 * Will override any auto detected language.
 * @param languageCode ISO 639-1 two-letter language code
 */
brainCloudClient.overrideLanguageCode = function(languageCode) {
    brainCloudClient.languageCode = languageCode;
}

brainCloudClient.heartbeat = function(callback) {
    brainCloudManager.sendRequest({
        service : "heartbeat",
        operation : "READ",
        callback : callback
    });
};
/**
* @status complete
*/

    brainCloudClient.abtests = {};
    

    brainCloudClient.abtests.loadABTestData = function(dataUrl, callback) {
        console.log("called loadABTestData(" + dataUrl + ",callback)");
        
        // Retrieve AB Test data from AppServer S3 service.
        jQuery.ajax({
            timeout: 15000,
            url: dataUrl,
            type: "POST",
            contentType: "application/json",
            dataType: "json",
            data: JSON.stringify({})
        }).done(function (response) {
            // success... 
            console.log("loadABTestData() - GOT: " + JSON.stringify(response));
            if (response != null) {
                abTestData = response;
            }
            if (callback) {
                callback();
            }
        }).fail(function (jqXhr, textStatus, errorThrown) {
            // failure...
            console.log("loadABTestData() - FAILED: " + jqXhr + " " + textStatus + " " + errorThrown);
        });
    };

    brainCloudClient.abtests.getABTest = function(abTestingId, abTestName) {
        console.log("called getABTest(" + abTestingId + "," + abTestName + ").");
        // Process the AB Test data and determine if an active test exists that satisfies the supplied parameters.
        for (var x = 0; x < abTestData.ab_tests.length; x++) {
            if (abTestData.ab_tests[x].name == abTestName && abTestData.ab_tests[x].active == "true") {
                for (var y = 0; y < abTestData.ab_tests[x].data.length; y++) {
                    // Check the ab_testing_id against the range defined in the test.
                    var minId = abTestData.ab_tests[x].data[y].min;
                    var maxId = abTestData.ab_tests[x].data[y].max;
                    
                    if (abTestingId >= minId && abTestingId <= maxId) {
                        console.log("getABTest() - Found AB test '" + abTestName + ":" + abTestData.ab_tests[x].data[y].name + "' for abTestingId '" + abTestingId + "' in range '" + minId + "' to '" + maxId + "'.");
                        return abTestData.ab_tests[x].data[y].name;
                    }
                }
            }
        }
        console.log("getABTest() - Could not find an '" + abTestName + "' AB test for abTestingId '" + abTestingId + "'.");
        return null;
    };

    brainCloudClient.abtests.pushABTestResult = function(abTestingId, abTestName, abSelection, result) {
        console.log("called pushABTestResult(" + abTestingId + "," + abTestName + "," + abSelection + "," + result + ").");
/*
        // Push the AB Test result to MixPanel Analytics.
        mixpanel.track("ABTest", {
            'platform': 'javascript',
            'abTestingId': abTestingId,
            'abTestName': abTestName,
            'abSelection': abSelection,
            'result': result
        });*/
    };


    brainCloudClient.abtests.setABTestingId = function(abTestingId) {
        brainCloudManager.setABTestingId(abTestingId);
    };

    brainCloudClient.abtests.getABTestingId = function() {
        return brainCloudManager.getABTestingId();
    };


brainCloudClient.asyncMatch = {};

brainCloudClient.SERVICE_ASYNC_MATCH = "asyncMatch";

brainCloudClient.asyncMatch.OPERATION_SUBMIT_TURN = "SUBMIT_TURN";
brainCloudClient.asyncMatch.OPERATION_UPDATE_SUMMARY = "UPDATE_SUMMARY";
brainCloudClient.asyncMatch.OPERATION_ABANDON = "ABANDON";
brainCloudClient.asyncMatch.OPERATION_COMPLETE = "COMPLETE";
brainCloudClient.asyncMatch.OPERATION_CREATE = "CREATE";
brainCloudClient.asyncMatch.OPERATION_READ_MATCH = "READ_MATCH";
brainCloudClient.asyncMatch.OPERATION_READ_MATCH_HISTORY = "READ_MATCH_HISTORY";
brainCloudClient.asyncMatch.OPERATION_FIND_MATCHES = "FIND_MATCHES";
brainCloudClient.asyncMatch.OPERATION_FIND_MATCHES_COMPLETED = "FIND_MATCHES_COMPLETED";
brainCloudClient.asyncMatch.OPERATION_DELETE_MATCH = "DELETE_MATCH";

/**
 * Creates an instance of an asynchronous match.
 *
 * Service Name - AsyncMatch
 * Service Operation - Create
 *
 * @param opponentIds  JSON string identifying the opponent platform and id for this match.
 *
 * Platforms are identified as:
 * BC - a brainCloud profile id
 * FB - a Facebook id
 *
 * An exmaple of this string would be:
 * [
 *     {
 *         "platform": "BC",
 *         "id": "some-braincloud-profile"
 *     },
 *     {
 *         "platform": "FB",
 *         "id": "some-facebook-id"
 *     }
 * ]
 *
 * @param pushNotificationMessage Optional push notification message to send to the other party.
 *  Refer to the Push Notification functions for the syntax required.
 * @param callback Optional instance of IServerCallback to call when the server response is received.
 */
brainCloudClient.asyncMatch.createMatch = function(opponentIds, pushNotificationMessage, callback) {

    var data = {
        players: opponentIds
    };
    if (pushNotificationMessage) {
        data["pushContent"] = pushNotificationMessage;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ASYNC_MATCH,
        operation: brainCloudClient.asyncMatch.OPERATION_CREATE,
        data: data,
        callback: callback
    });
};

/**
 * Creates an instance of an asynchronous match with an initial turn.
 *
 * Service Name - AsyncMatch
 * Service Operation - Create
 *
 * @param opponentIds  JSON string identifying the opponent platform and id for this match.
 *
 * Platforms are identified as:
 * BC - a brainCloud profile id
 * FB - a Facebook id
 *
 * An exmaple of this string would be:
 * [
 *     {
 *         "platform": "BC",
 *         "id": "some-braincloud-profile"
 *     },
 *     {
 *         "platform": "FB",
 *         "id": "some-facebook-id"
 *     }
 * ]
 *
 * @param matchState    JSON string blob provided by the caller
 * @param pushNotificationMessage Optional push notification message to send to the other party.
 * Refer to the Push Notification functions for the syntax required.
 * @param nextPlayer Optionally, force the next player player to be a specific player
 * @param summary Optional JSON string defining what the other player will see as a summary of the game when listing their games
 * @param callback Optional instance of IServerCallback to call when the server response is received.
 */
brainCloudClient.asyncMatch.createMatchWithInitialTurn = function(opponentIds, matchState,
        pushNotificationMessage, nextPlayer, summary, callback) {
    var data = {
        players: opponentIds
    };
    if (matchState) {
        data["matchState"] = matchState;
    }
    else data["matchState"] = {};
    if (pushNotificationMessage) {
        data["pushContent"] = pushNotificationMessage;
    }
    if (nextPlayer) {
        data["status"] = { currentPlayer: nextPlayer };
    }
    if (summary) {
        data["summary"] = summary;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ASYNC_MATCH,
        operation: brainCloudClient.asyncMatch.OPERATION_CREATE,
        data: data,
        callback: callback
    });
};

/**
 * Returns the current state of the given match.
 *
 * Service Name - AsyncMatch
 * Service Operation - ReadMatch
 *
 * @param ownerId   Match owner identifier
 * @param matchId   Match identifier
 * @param callback  Optional instance of IServerCallback to call when the server response is received.
 */
brainCloudClient.asyncMatch.readMatch = function(ownerId, matchId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ASYNC_MATCH,
        operation: brainCloudClient.asyncMatch.OPERATION_READ_MATCH,
        data: {
            ownerId: ownerId,
            matchId: matchId
        },
        callback: callback
    });
};

/**
 * Submits a turn for the given match.
 *
 * Service Name - AsyncMatch
 * Service Operation - SubmitTurn
 *
 * @param ownerId Match owner identfier
 * @param matchId Match identifier
 * @param version Game state version to ensure turns are submitted once and in order
 * @param matchState JSON string provided by the caller
 * @param pushNotificationMessage Optional push notification message to send to the other party.
 *  Refer to the Push Notification functions for the syntax required.
 * @param nextPlayer Optionally, force the next player player to be a specific player
 * @param summary Optional JSON string that other players will see as a summary of the game when listing their games
 * @param statistics Optional JSON string blob provided by the caller
 * @param callback Optional instance of IServerCallback to call when the server response is received.
 */
brainCloudClient.asyncMatch.submitTurn = function(ownerId, matchId, version, matchState,
        pushNotificationMessage, nextPlayer, summary, statistics, callback) {
    var data = {
        ownerId: ownerId,
        matchId: matchId,
        version: version
    };
    if (matchState) {
        data["matchState"] = matchState;
    }
    if (nextPlayer) {
        data["status"] = { currentPlayer: nextPlayer };
    }
    if (summary) {
        data["summary"] = summary;
    }
    if (statistics) {
        data["statistics"] = statistics;
    }
    if(pushNotificationMessage){
        data["pushContent"] = pushNotificationMessage;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ASYNC_MATCH,
        operation: brainCloudClient.asyncMatch.OPERATION_SUBMIT_TURN,
        data: data,
        callback: callback
    });
};

/**
 * Allows the current player (only) to update Summary data without having to submit a whole turn.
 *
 * Service Name - AsyncMatch
 * Service Operation - UpdateMatchSummary
 *
 * @param ownerId Match owner identfier
 * @param matchId Match identifier
 * @param version Game state version to ensure turns are submitted once and in order
 * @param summary JSON string that other players will see as a summary of the game when listing their games
 * @param callback Optional instance of IServerCallback to call when the server response is received.
 */
brainCloudClient.asyncMatch.updateMatchSummaryData = function(ownerId, matchId, version, summary, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ASYNC_MATCH,
        operation: brainCloudClient.asyncMatch.OPERATION_UPDATE_SUMMARY,
        data: {
            ownerId: ownerId,
            matchId: matchId,
            version: version,
            summary: summary
        },
        callback: callback
    });
};

/**
 * Marks the given match as abandoned.
 *
 * Service Name - AsyncMatch
 * Service Operation - Abandon
 *
 * @param ownerId   Match owner identifier
 * @param matchId   Match identifier
 * @param callback  Optional instance of IServerCallback to call when the server response is received.
 */
brainCloudClient.asyncMatch.abandonMatch = function(ownerId, matchId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ASYNC_MATCH,
        operation: brainCloudClient.asyncMatch.OPERATION_ABANDON,
        data: {
            ownerId: ownerId,
            matchId: matchId
        },
        callback: callback
    });
};

/**
 * Marks the given match as complete.
 *
 * Service Name - AsyncMatch
 * Service Operation - Complete
 *
 * @param ownerId Match owner identifier
 * @param matchId Match identifier
 * @param callback Optional instance of IServerCallback to call when the server response is received.
 */
brainCloudClient.asyncMatch.completeMatch = function(ownerId, matchId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ASYNC_MATCH,
        operation: brainCloudClient.asyncMatch.OPERATION_COMPLETE,
        data: {
            ownerId: ownerId,
            matchId: matchId
        },
        callback: callback
    });
};

/**
 * Returns the match history of the given match.
 *
 * Service Name - AsyncMatch
 * Service Operation - ReadMatchHistory
 *
 * @param ownerId   Match owner identifier
 * @param matchId   Match identifier
 * @param callback  Optional instance of IServerCallback to call when the server response is received.
 */
brainCloudClient.asyncMatch.readMatchHistory = function(ownerId, matchId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ASYNC_MATCH,
        operation: brainCloudClient.asyncMatch.OPERATION_READ_MATCH_HISTORY,
        data: {
            ownerId: ownerId,
            matchId: matchId
        },
        callback: callback
    });
};

/**
 * Returns all matches that are NOT in a COMPLETE state for which the player is involved.
 *
 * Service Name - AsyncMatch
 * Service Operation - FindMatches
 *
 * @param callback  Optional instance of IServerCallback to call when the server response is received.
 */
brainCloudClient.asyncMatch.findMatches = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ASYNC_MATCH,
        operation: brainCloudClient.asyncMatch.OPERATION_FIND_MATCHES,
        callback: callback
    });
};

/**
 * Returns all matches that are in a COMPLETE state for which the player is involved.
 *
 * Service Name - AsyncMatch
 * Service Operation - FindMatchesCompleted
 *
 * @param callback  Optional instance of IServerCallback to call when the server response is received.
 */
brainCloudClient.asyncMatch.findCompleteMatches = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ASYNC_MATCH,
        operation: brainCloudClient.asyncMatch.OPERATION_FIND_MATCHES_COMPLETED,
        callback: callback
    });
};


/**
 * Removes the match and match history from the server. DEBUG ONLY, in production it is recommended
 *   the user leave it as completed.
 *
 * Service Name - AsyncMatch
 * Service Operation - Delete
 *
 * @param ownerId   Match owner identifier
 * @param matchId   Match identifier
 * @param callback  Optional instance of IServerCallback to call when the server response is received.
 */
brainCloudClient.asyncMatch.deleteMatch = function(ownerId, matchId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ASYNC_MATCH,
        operation: brainCloudClient.asyncMatch.OPERATION_DELETE_MATCH,
        data: {
            ownerId: ownerId,
            matchId: matchId
        },
        callback: callback
    });
};
brainCloudClient.authentication = {};

brainCloudClient.SERVICE_AUTHENTICATION = "authenticationV2";

brainCloudClient.authentication.OPERATION_AUTHENTICATE = "AUTHENTICATE";
brainCloudClient.authentication.OPERATION_RESET_EMAIL_PASSWORD = "RESET_EMAIL_PASSWORD";

brainCloudClient.authentication.AUTHENTICATION_TYPE_ANONYMOUS = "Anonymous";
brainCloudClient.authentication.AUTHENTICATION_TYPE_EMAIL = "Email";
brainCloudClient.authentication.AUTHENTICATION_TYPE_EXTERNAL = "External";
brainCloudClient.authentication.AUTHENTICATION_TYPE_FACEBOOK = "Facebook";
brainCloudClient.authentication.AUTHENTICATION_TYPE_GOOGLE = "Google";
brainCloudClient.authentication.AUTHENTICATION_TYPE_UNIVERSAL = "Universal";
brainCloudClient.authentication.AUTHENTICATION_TYPE_GAME_CENTER = "GameCenter";
brainCloudClient.authentication.AUTHENTICATION_TYPE_STEAM = "Steam";
brainCloudClient.authentication.AUTHENTICATION_TYPE_TWITTER = "Twitter";
brainCloudClient.authentication.AUTHENTICATION_TYPE_PARSE = "Parse";

brainCloudClient.authentication.profileId = "";
brainCloudClient.authentication.anonymousId = "";

/**
 * Initialize - initializes the identity service with the saved
 * anonymous installation id and most recently used profile id
 *
 * @param anonymousId  The anonymous installation id that was generated for this device
 * @param profileId The id of the profile id that was most recently used by the app (on this device)
 */
brainCloudClient.authentication.initialize = function(profileId, anonymousId) {
    brainCloudClient.authentication.anonymousId = anonymousId;
    brainCloudClient.authentication.profileId = profileId;
};

/**
* Used to create the anonymous installation id for the brainCloud profile.
* @returns A unique Anonymous ID
*/
brainCloudClient.authentication.generateAnonymousId = function() {   
    var d = new Date().getTime();
    if(window.performance && typeof window.performance.now === "function"){
        d += performance.now(); //use high-precision timer if available
    }
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
    });
    return uuid;
};

/**
* @deprecated Use generateAnonymousId() instead - Removal after August 17 2016
*/
brainCloudClient.authentication.generateGUID = function() {
    console.log("generateGUID is deprecated - Use generateAnonymousId() instead - Removal after August 17 2016");
    var d = new Date().getTime();
    if(window.performance && typeof window.performance.now === "function"){
        d += performance.now(); //use high-precision timer if available
    }
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
    });
    return uuid;
};

/**
* @deprecated Use generateAnonymousId() instead - Removal after August 17 2016
*/
brainCloudClient.authentication.generateNewAnonymousId = function() {
    console.log("generateNewAnonymousId is deprecated - Use generateAnonymousId() instead - Removal after August 17 2016");
    brainCloudClient.authentication.anonymousId =
        brainCloudClient.authentication.generateGUID();
};

/**
 * Used to clear the saved profile id - to use in cases when the user is
 * attempting to switch to a different profile.
 */
brainCloudClient.authentication.clearSavedProfileId = function() {
    brainCloudClient.authentication.profileId = "";
};

/**
 * Authenticate a user anonymously with brainCloud - used for apps that don't want to bother
 * the user to login, or for users who are sensitive to their privacy
 *
 * Service Name - authenticationV2
 * Service Operation - AUTHENTICATE
 *
 * @param forceCreate  Should a new profile be created if it does not exist?
 * @param callback The method to be invoked when the server response is received
 *
 */
brainCloudClient.authentication.authenticateAnonymous = function(forceCreate, callback) {
    brainCloudClient.authentication.authenticate(
        this.anonymousId,
        "",
        brainCloudClient.authentication.AUTHENTICATION_TYPE_ANONYMOUS,
        null,
        forceCreate,
        callback);
};

/**
 * Authenticate the user with a custom Email and Password. Note that the client app
 * is responsible for collecting and storing the e-mail and potentially password
 * (for convenience) in the client data. For the greatest security,
 * force the user to re-enter their password at each login
 * (or at least give them that option).
 *
 * Service Name - authenticationV2
 * Service Operation - AUTHENTICATE
 *
 * @param email {string} - The e-mail address of the user
 * @param password {string} - The password of the user
 * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
 * @param responseHandler {function} - The user callback method
 */
brainCloudClient.authentication.authenticateEmailPassword = function(email, password, forceCreate, responseHandler) {
    brainCloudClient.authentication.authenticate(
        email,
        password,
        brainCloudClient.authentication.AUTHENTICATION_TYPE_EMAIL,
        null,
        forceCreate,
        responseHandler);
};

/**
 * Authenticate the user via cloud code (which in turn validates the supplied credentials against an external system).
 * This allows the developer to extend brainCloud authentication to support other backend authentication systems.
 *
 * Service Name - authenticationV2
 * Service Operation - AUTHENTICATE
 *
 * @param userId {string} - The userId
 * @param token {string} - The user token (password etc)
 * @param externalAuthName {string} - The name of the cloud script to call for external authentication
 * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
 * @param responseHandler {function} - The user callback method
 */
brainCloudClient.authentication.authenticateExternal = function(userId, token, externalAuthName, forceCreate, responseHandler) {
    brainCloudClient.authentication.authenticate(
        userId,
        token,
        brainCloudClient.authentication.AUTHENTICATION_TYPE_EXTERNAL,
        externalAuthName,
        forceCreate,
        responseHandler);
};

/**
 * Authenticate the user with brainCloud using their Facebook Credentials
 *
 * Service Name - authenticationV2
 * Service Operation - AUTHENTICATE
 *
 * @param facebookId {string} - The Facebook id of the user
 * @param facebookToken {string} - The validated token from the Facebook SDK
 * (that will be further validated when sent to the bC service)
 * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
 * @param responseHandler {function} - The user callback method
 */
brainCloudClient.authentication.authenticateFacebook = function(facebookId, facebookToken, forceCreate, responseHandler) {
    brainCloudClient.authentication.authenticate(
        facebookId,
        facebookToken,
        brainCloudClient.authentication.AUTHENTICATION_TYPE_FACEBOOK,
        null,
        forceCreate,
        responseHandler);
};

/**
 * Authenticate the user using their Game Center id
 *
 * Service Name - authenticationV2
 * Service Operation - AUTHENTICATE
 *
 * @param gameCenterId {string} - The player's game center id
 *                              (use the playerID property from the local GKPlayer object)
 * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
 * @param responseHandler {function} - The user callback method
 */
brainCloudClient.authentication.authenticateGameCenter = function(gameCenterId, forceCreate, responseHandler) {
    brainCloudClient.authentication.authenticate(
        gameCenterId,
        null,
        brainCloudClient.authentication.AUTHENTICATION_TYPE_GAME_CENTER,
        null,
        forceCreate,
        responseHandler);
};

/**
 * Authenticate the user using a google user id (email address) and google authentication token.
 *
 * Service Name - authenticationV2
 * Service Operation - AUTHENTICATE
 *
 * @param googleId {string} - String representation of google+ userid (email)
 * @param googleToken {string} - The authentication token derived via the google apis.
 * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
 * If set to false, you need to handle errors in the case of new players.
 * @param responseHandler {function} - The user callback method
 */
brainCloudClient.authentication.authenticateGoogle = function(googleId, googleToken, forceCreate, responseHandler) {
    brainCloudClient.authentication.authenticate(
        googleId,
        googleToken,
        brainCloudClient.authentication.AUTHENTICATION_TYPE_GOOGLE,
        null,
        forceCreate,
        responseHandler);
};

/**
 * Authenticate the user using a steam userId and session ticket (without any validation on the userId).
 *
 * Service Name - authenticationV2
 * Service Operation - AUTHENTICATE
 *
 * @param userid  String representation of 64 bit steam id
 * @param sessionticket  The session ticket of the user (hex encoded)
 * @param forceCreate Should a new profile be created for this user if the account does not exist?
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.authentication.authenticateSteam = function(userId, sessionTicket, forceCreate, responseHandler) {
    brainCloudClient.authentication.authenticate(
        userId,
        sessionTicket,
        brainCloudClient.authentication.AUTHENTICATION_TYPE_STEAM,
        null,
        forceCreate,
        responseHandler);
};


/**
 * Authenticate the user using a Twitter user ID, authentication token, and secret from Twitter
 *
 * Service Name - authenticationV2
 * Service Operation - AUTHENTICATE
 *
 * @param userId {string} - String representation of Twitter user ID
 * @param token {string} - The authentication token derived via the Twitter APIs
 * @param secret {string} - The secret given when attempting to link with Twitter
 * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
 * If set to false, you need to handle errors in the case of new players.
 * @param responseHandler {function} - The user callback method
 */
brainCloudClient.authentication.authenticateTwitter = function(userId, token, secret, forceCreate, responseHandler) {
    brainCloudClient.authentication.authenticate(
        userId,
        token + ":" + secret,
        brainCloudClient.authentication.AUTHENTICATION_TYPE_TWITTER,
        null,
        forceCreate,
        responseHandler);
};

/** Method authenticates the user using universal credentials
 *
 * Service Name - authenticationV2
 * Service Operation - AUTHENTICATE
 *
 * @param userId {string} - The user's id. Can be any string you want.
 * @param userPassword {string} - The user's password. Can be any string you want.
 * @param forceCreate {boolean} - True if we force creation of the player if they do not already exist.
 * If set to false, you need to handle errors in the case of new players.
 * @param responseHandler {function} - The user callback method
 */
brainCloudClient.authentication.authenticateUniversal = function(userId, userPassword, forceCreate, responseHandler) {
    brainCloudClient.authentication.authenticate(
        userId,
        userPassword,
        brainCloudClient.authentication.AUTHENTICATION_TYPE_UNIVERSAL,
        null,
        forceCreate,
        responseHandler);
};

/**
 * Authenticate the user using a Pase userid and authentication token
 *
 * Service Name - Authenticate
 * Service Operation - Authenticate
 *
 * @param userId String representation of Parse userid
 * @param token The authentication token
 * @param forceCreate Should a new profile be created for this user if the account does not exist?
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.authentication.authenticateParse = function(userId, token, forceCreate, responseHandler) {
    brainCloudClient.authentication.authenticate(
        userId,
        token,
        brainCloudClient.authentication.AUTHENTICATION_TYPE_PARSE,
        null,
        forceCreate,
        responseHandler);
};

/**
 * Reset Email password - sends a password reset email to the specified address
 *
 * Service Name - authenticationV2
 * Operation - ResetEmailPassword
 *
 * @param email {string} - The email address to send the reset email to.
 * @param responseHandler {function} - The user callback method
 *
 * Note the follow error reason codes:
 *
 * SECURITY_ERROR (40209) - If the email address cannot be found.
 */
brainCloudClient.authentication.resetEmailPassword = function(email, responseHandler) {
    var callerCallback = responseHandler;
    var appId = brainCloudManager.getAppId();

    var request = {
        service: brainCloudClient.SERVICE_AUTHENTICATION,
        operation: brainCloudClient.authentication.OPERATION_RESET_EMAIL_PASSWORD,
        data: {
            gameId: appId,
            externalId: email
        },
        callerCallback: responseHandler,
        callback: function(result) {
            if (result && result.status == 200) {

            }
            if (callerCallback) {
                callerCallback(result);
            }
            //console.log("CallerCallback: " + callerCallback);
        }

    };
    //console.log("Request: " + JSON.stringify(request));
    brainCloudManager.sendRequest(request);
};

/** Method allows a caller to authenticate with brainCloud. Note that
 * callers should use the other authenticate methods in this class as
 * they incorporate the appropriate authenticationType and use better
 * parameter names for credentials.
 *
 * @param externalId {string} - The external id
 * @param authenticationToken {string} - The authentication token (sometimes the password)
 * @param authenticationType {string} - The type of authentication to use
 * @param externalAuthName {string} - The name of the external authentication script (if using External auth type)
 * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
 * @param responseHandler {function} - The user callback method
 */
brainCloudClient.authentication.authenticate = function(externalId, authenticationToken, authenticationType, externalAuthName, forceCreate, responseHandler) {
    var callerCallback = responseHandler;
    // The joy of closures...
    // See: http://stackoverflow.com/questions/1484143/scope-chain-in-javascript
    // And: http://jibbering.com/faq/notes/closures/
    //console.log("authenticateV2 CallerCallback: " + callerCallback);

    var _navLangCode = window.navigator.userLanguage || window.navigator.language;
    _navLangCode = _navLangCode.split("-");
    var languageCode =  brainCloudClient.languageCode == null ? _navLangCode[0] : brainCloudClient.languageCode;
    var countryCode = brainCloudClient.countryCode == null ? _navLangCode[1] : brainCloudClient.countryCode;

    var now = new Date();
    var timeZoneOffset = -now.getTimezoneOffset() / 60.0;

    var appId = brainCloudManager.getAppId();
    var appVersion = brainCloudManager.getAppVersion();

    // make sure session id for our session is clear...
    brainCloudManager.setSessionId("");

    var data = {
        gameId: appId,
        externalId: externalId,
        releasePlatform: "WEB",
        gameVersion: appVersion,
        clientLibVersion: brainCloudClient.version,
        authenticationToken: authenticationToken,
        authenticationType: authenticationType,
        forceCreate: forceCreate,
        anonymousId: brainCloudClient.authentication.anonymousId,
        profileId: brainCloudClient.authentication.profileId,
        timeZoneOffset: timeZoneOffset,
        languageCode: languageCode,
        countryCode: countryCode,
        clientLib: "js"
    };

    if (externalAuthName) {
        data["externalAuthName"] = externalAuthName;
    };

    var request = {
        service: brainCloudClient.SERVICE_AUTHENTICATION,
        operation: brainCloudClient.authentication.OPERATION_AUTHENTICATE,
        data: data,

        callback: function(result) {
            // Use our own function as the callback (effectively intercept it),
            // and then call the callersCallback if set...

            // Auto set userid and sessionid based on response...
            if (result && result.status == 200) {
                brainCloudManager.setABTestingId(result.data.abTestingId);
                brainCloudManager.setSessionId(result.data.sessionId);
                brainCloudClient.authentication.profileId = result.data.profileId;
            }
            if (callerCallback) {
                callerCallback(result);
            }
        }

    };
    brainCloudManager.sendRequest(request);
};

/**
 * Using invokeRawAPI you can execute a raw brainCloud call.
 *
 * @param {string}
 *            service - The brainCloud service
 * @param {string}
 *            operation - The brainCloud operation to execute
 * @param {object}
 *            data - The JSON data to sent to brainCloud
 * @param {function}
 *            callback - The callback handler function
 */
brainCloudClient.invokeRawAPI = function(service, operation, data, callback) {

    var isAuthOp = false;
    if (service == brainCloudClient.SERVICE_AUTHENTICATION) {
        if (operation == brainCloudClient.authentication.OPERATION_AUTHENTICATE) {
            isAuthOp = true;
            brainCloudClient.setSessionId("");
        }
    }

    var request = {
        service: service,
        operation: operation,
        data: data,
        callback: function(result) {

            if (isAuthOp) {
                if (result && result.status == 200) {
                    // console.log("Authenticating... result was OK");
                    brainCloudClient.setABTestingId(result.data.abTestingId);
                    brainCloudClient.setUserId(result.data.userId);
                    brainCloudClient.setSessionId(result.data.sessionId);
                }
            }
            if (callback) {
                callback(result);
            }
        }
    };
    // console.log("Request: " + JSON.stringify(request));
    brainCloudManager.sendRequest(request);
};

brainCloudClient.dataStream = {};

brainCloudClient.SERVICE_DATA_STREAM = "dataStream";

brainCloudClient.dataStream.OPERATION_CUSTOM_PAGE_EVENT = "CUSTOM_PAGE_EVENT";
brainCloudClient.dataStream.OPERATION_CUSTOM_SCREEN_EVENT = "CUSTOM_SCREEN_EVENT";
brainCloudClient.dataStream.OPERATION_CUSTOM_TRACK_EVENT = "CUSTOM_TRACK_EVENT";

/**
 * Creates custom data stream page event
 *
 * @param eventName
 *            {string} Name of event
 * @param eventProperties
 *            {json} Properties of event
 * @param callback
 *            {function} The callback handler.
 */
brainCloudClient.dataStream.customPageEvent = function(eventName, eventProperties, callback) {
    var message = {
        eventName : eventName
    };

    if (eventProperties) {
        message["eventProperties"] = eventProperties;
    }

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_DATA_STREAM,
        operation : brainCloudClient.dataStream.OPERATION_CUSTOM_PAGE_EVENT,
        data : message,
        callback : callback
    });
};


/**
 * Creates custom data stream screen event
 *
 * @param eventName
 *            {string} Name of event
 * @param eventProperties
 *            {json} Properties of event
 * @param callback
 *            {function} The callback handler.
 */
brainCloudClient.dataStream.customScreenEvent = function(eventName, eventProperties, callback) {
    var message = {
        eventName : eventName
    };

    if (eventProperties) {
        message["eventProperties"] = eventProperties;
    }

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_DATA_STREAM,
        operation : brainCloudClient.dataStream.OPERATION_CUSTOM_SCREEN_EVENT,
        data : message,
        callback : callback
    });
};


/**
 * Creates custom data stream track event
 *
 * @param eventName
 *            {string} Name of event
 * @param eventProperties
 *            {json} Properties of event
 * @param callback
 *            {function} The callback handler.
 */
brainCloudClient.dataStream.customTrackEvent = function(eventName, eventProperties, callback) {
    var message = {
        eventName : eventName
    };

    if (eventProperties) {
        message["eventProperties"] = eventProperties;
    }

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_DATA_STREAM,
        operation : brainCloudClient.dataStream.OPERATION_CUSTOM_TRACK_EVENT,
        data : message,
        callback : callback
    });
};

brainCloudClient.entity = {};

brainCloudClient.SERVICE_ENTITY = "entity";

brainCloudClient.entity.OPERATION_READ = "READ";
brainCloudClient.entity.OPERATION_CREATE = "CREATE";
brainCloudClient.entity.OPERATION_READ_BY_TYPE = "READ_BY_TYPE";
brainCloudClient.entity.OPERATION_READ_SHARED = "READ_SHARED";
brainCloudClient.entity.OPERATION_READ_SHARED_ENTITY = "READ_SHARED_ENTITY";
brainCloudClient.entity.OPERATION_READ_SINGLETON = "READ_SINGLETON";
brainCloudClient.entity.OPERATION_UPDATE = "UPDATE";
brainCloudClient.entity.OPERATION_UPDATE_SHARED = "UPDATE_SHARED";
brainCloudClient.entity.OPERATION_UPDATE_SINGLETON = "UPDATE_SINGLETON";
brainCloudClient.entity.OPERATION_UPDATE_PARTIAL = "UPDATE_PARTIAL";
brainCloudClient.entity.OPERATION_DELETE = "DELETE";
brainCloudClient.entity.OPERATION_DELETE_SINGLETON = "DELETE_SINGLETON";
brainCloudClient.entity.OPERATION_GET_LIST = "GET_LIST";
brainCloudClient.entity.OPERATION_GET_LIST_COUNT = "GET_LIST_COUNT";
brainCloudClient.entity.OPERATION_GET_PAGE = "GET_PAGE";
brainCloudClient.entity.OPERATION_GET_PAGE_BY_OFFSET = "GET_PAGE_BY_OFFSET";
brainCloudClient.entity.OPERATION_READ_SHARED_ENTITIES_LIST = "READ_SHARED_ENTITIES_LIST";
brainCloudClient.entity.OPERATION_INCREMENT_USER_ENTITY_DATA = "INCREMENT_USER_ENTITY_DATA";
brainCloudClient.entity.OPERATION_INCREMENT_SHARED_USER_ENTITY_DATA = "INCREMENT_SHARED_USER_ENTITY_DATA";

/**
 * Method creates a new entity on the server.
 *
 * @param entityType
 *            {string} The entity type as defined by the user
 * @param data
 *            {json} The entity's data as a json string
 * @param acl
 *            {json} The entity's access control list as json. A null acl
 *            implies default permissions which make the entity
 *            readable/writeable by only the user.
 * @param callback
 *            {function} The callback handler.
 */
brainCloudClient.entity.createEntity = function(entityType, data, acl, callback) {
    var message = {
        entityType : entityType,
        data : data
    };

    if (acl) {
        message["acl"] = acl;
    }

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_CREATE,
        data : message,
        callback : callback
    });
};

/**
 * Method to get a specific entity.
 *
 * @param entityId
 *            {string} The id of the entity
 * @param callback
 *            {function} The callback handler
 */
brainCloudClient.entity.getEntity = function(entityId, callback) {
    var message = {
        entityId : entityId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_READ,
        data : message,
        callback : callback
    });
};

/**
 * Method returns all user entities that match the given type.
 *
 * @param entityType
 *            {string} The entity type to retrieve
 * @param callback
 *            {function} The callback handler
 */
brainCloudClient.entity.getEntitiesByType = function(entityType, callback) {
    var message = {
        entityType : entityType
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_READ_BY_TYPE,
        data : message,
        callback : callback
    });
};

/**
 * @deprecated Use getSharedEntityForProfileId() instead - Removal after September 1 2017
 */
brainCloudClient.entity.getSharedEntityForPlayerId = function(profileId, entityId, callback) {
    var message = {
        targetPlayerId : profileId,
        entityId: entityId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_READ_SHARED_ENTITY,
        data : message,
        callback : callback
    });
};

/**
* Method returns a shared entity for the given profile and entity ID.
* An entity is shared if its ACL allows for the currently logged
* in user to read the data.
*
* Service Name - Entity
* Service Operation - READ_SHARED_ENTITY
*
* @param profileId The the profile ID of the user who owns the entity
* @param entityId The ID of the entity that will be retrieved
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.entity.getSharedEntityForProfileId = function(profileId, entityId, callback) {
    var message = {
        targetPlayerId : profileId,
        entityId: entityId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_READ_SHARED_ENTITY,
        data : message,
        callback : callback
    });
};

/**
 * @deprecated Use getSharedEntitiesForProfileId() instead - Removal after September 1 2017
 */
brainCloudClient.entity.getSharedEntitiesForPlayerId = function(profileId, callback) {
    var message = {
        targetPlayerId : profileId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_READ_SHARED,
        data : message,
        callback : callback
    });
};

/**
 * Method returns all shared entities for the given profile id.
 * An entity is shared if its ACL allows for the currently logged
 * in user to read the data.
 *
 * Service Name - Entity
 * Service Operation - ReadShared
 *
 * @param profileId The profile id to retrieve shared entities for
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.entity.getSharedEntitiesForProfileId = function(profileId, callback) {
    var message = {
        targetPlayerId : profileId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_READ_SHARED,
        data : message,
        callback : callback
    });
};

/**
 * @deprecated Use getAppId() instead - Removal after September 1 2017
 */
brainCloudClient.entity.getSharedEntitiesListForPlayerId = function(profileId, where, orderBy, maxReturn, callback) {
    var message = {
        targetPlayerId : profileId,
        maxReturn : maxReturn
    };

    if(where) message.where = where;
    if(orderBy) message.orderBy = orderBy;

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_READ_SHARED_ENTITIES_LIST,
        data : message,
        callback : callback
    });
}

/**
* Method gets list of shared entities for the specified user based on type and/or where clause
*
* Service Name - entity
* Service Operation - READ_SHARED_ENTITIES_LIST
*
* @param profileId The profile ID to retrieve shared entities for
* @param where Mongo style query
* @param orderBy Sort order
* @param maxReturn The maximum number of entities to return
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.entity.getSharedEntitiesListForProfileId = function(profileId, where, orderBy, maxReturn, callback) {
    var message = {
        targetPlayerId : profileId,
        maxReturn : maxReturn
    };

    if(where) message.where = where;
    if(orderBy) message.orderBy = orderBy;

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_READ_SHARED_ENTITIES_LIST,
        data : message,
        callback : callback
    });
}

/**
 * Method updates an entity. This operation results in the entity data being
 * completely replaced by the passed in JSON string.
 *
 * @param entityId
 *            {string} The id of the entity to update
 * @param entityType
 *            {string} The entity type as defined by the user
 * @param data
 *            {json} The entity's data as a json string.
 * @param acl
 *            {json} The entity's access control list as json. A null acl
 *            implies default permissions which make the entity
 *            readable/writeable by only the user.
 * @param version
 *            {number} Current version of the entity. If the version of the
 *            entity on the server does not match the version passed in, the
 *            server operation will fail. Use -1 to skip version checking.
 * @param callback
 *            {function} The callback handler
 */
brainCloudClient.entity.updateEntity = function(entityId, entityType, data,
        acl, version, callback) {
    var message = {
        entityId : entityId,
        data : data,
        version : version
    };

    if (entityType) {
        message["entityType"] = entityType;
    }

    if (acl) {
        message["acl"] = acl;
    }

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_UPDATE,
        data : message,
        callback : callback
    });
};

/**
 * Method updates another user's entity. This operation results in the entity
 * data being completely replaced by the passed in JSON string.
 *
 * @param targetProfileId
 *            {string} The entity's owning profle id
 * @param entityId
 *            {string} The id of the entity to update
 * @param entityType
 *            {string} The entity type as defined by the user
 * @param data
 *            {json} The entity's data as a json string.
 * @param version
 *            {number} Current version of the entity. If the version of the
 *            entity on the server does not match the version passed in, the
 *            server operation will fail. Use -1 to skip version checking.
 * @param callback
 *            {function} The callback handler
 */
brainCloudClient.entity.updateSharedEntity = function(entityId, targetProfileId,
        entityType, data, version, callback) {
    var message = {
        targetPlayerId : targetProfileId,
        entityId : entityId,
        data : data,
        version : version
    };

    if (entityType) {
        message["entityType"] = entityType;
    }

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_UPDATE_SHARED,
        data : message,
        callback : callback
    });
};

/**
 * Method updates a singleton entity. This operation results in the entity data
 * being completely replaced by the passed in JSON string.
 *
 * @param entityType
 *            {string} The entity type as defined by the user
 * @param data
 *            {json} The entity's data as a json string.
 * @param acl
 *            {json} The entity's access control list as json. A null acl
 *            implies default permissions which make the entity
 *            readable/writeable by only the user.
 * @param version
 *            {number} Current version of the entity. If the version of the
 *            entity on the server does not match the version passed in, the
 *            server operation will fail. Use -1 to skip version checking.
 * @param callback
 *            {function} The callback handler
 */
brainCloudClient.entity.updateSingleton = function(entityType, data, acl,
        version, callback) {
    var message = {
        entityType : entityType,
        data : data,
        version : version
    };

    if (acl) {
        message["acl"] = acl;
    }

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_UPDATE_SINGLETON,
        data : message,
        callback : callback
    });
};

/**
 * Method retrieves a singleton entity on the server. If the entity doesn't exist, null is returned.
 *
 * @param entityType
 *            {string} The entity type as defined by the user
 * @param callback
 *            {function} Callback handler
 */
brainCloudClient.entity.getSingleton = function(entityType, callback) {
    var message = {
        entityType : entityType
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_READ_SINGLETON,
        data : message,
        callback : callback
    });
};

/**
 * Method to delete the specified entity for the user.
 *
 * @param entityId
 *            {string} ID of the entity
 * @param version
 *            {number} Current version of the entity. If the version of the
 *            entity on the server does not match the version passed in, the
 *            server operation will fail. Use -1 to skip version checking.
 * @param callback
 *            {function} Callback handler
 */
brainCloudClient.entity.deleteEntity = function(entityId, version, callback) {
    var message = {
        entityId : entityId,
        version : version
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_DELETE,
        data : message,
        callback : callback
    });
};

/**
 * Method to delete the specified singleton entity for the user.
 *
 * @param entityType
 *            {string} Type of the entity to delete
 * @param version
 *            {number} Current version of the entity. If the version of the
 *            entity on the server does not match the version passed in, the
 *            server operation will fail. Use -1 to skip version checking.
 * @param callback
 *            {function} Callback handler
 */
brainCloudClient.entity.deleteSingleton = function(entityType, version,
        callback) {
    var message = {
        entityType : entityType,
        version : version
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_DELETE_SINGLETON,
        data : message,
        callback : callback
    });
};

/**
* Method gets list of entities from the server base on type and/or where clause
*
* Service Name - Entity
* Service Operation - GET_LIST
*
* @param whereJson Mongo style query string
* @param orderByJson Sort order
* @param maxReturn The maximum number of entities to return
* @param callback The callback object
*/
brainCloudClient.entity.getList = function(whereJson, orderByJson, maxReturn, callback) {
    var message = {
        where : whereJson,
        maxReturn : maxReturn
    };

    if (orderByJson) {
        message.orderBy = orderByJson;
    }

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_GET_LIST,
        data : message,
        callback : callback
        });
};

/**
* Method gets a count of entities based on the where clause
*
* Service Name - Entity
* Service Operation - GET_LIST_COUNT
*
* @param whereJson Mongo style query string
* @param callback The callback object
*/
brainCloudClient.entity.getListCount = function(whereJson, callback) {
    var message = {
        where : whereJson
    };

    brainCloudManager
        .sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_GET_LIST_COUNT,
        data : message,
        callback : callback
        });
};

/**
 * Method uses a paging system to iterate through entities
 * After retrieving a page of entities with this method,
 * use GetPageOffset() to retrieve previous or next pages.
 *
 * Service Name - Entity
 * Service Operation - GetPage
 *
 * @param context The json context for the page request.
 *                   See the portal appendix documentation for format.
 * @param callback The callback object
 */
brainCloudClient.entity.getPage = function(context, callback)
{
    var message = {
    context : context
    };

    brainCloudManager
        .sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_GET_PAGE,
        data : message,
        callback : callback
        });
};

/**
 * Method to retrieve previous or next pages after having called the GetPage method.
 *
 * Service Name - Entity
 * Service Operation - GetPageOffset
 *
 * @param context The context string returned from the server from a
 *      previous call to GetPage or GetPageOffset
 * @param pageOffset The positive or negative page offset to fetch. Uses the last page
 *      retrieved using the context string to determine a starting point.
 * @param callback The callback object
 */
brainCloudClient.entity.getPageOffset = function(context, pageOffset, callback)
{
    var message = {
    context : context,
    pageOffset : pageOffset
    };

    brainCloudManager
        .sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_GET_PAGE_BY_OFFSET,
        data : message,
        callback : callback
        });
};

/**
* Partial increment of entity data field items. Partial set of items incremented as specified.
*
* Service Name - entity
* Service Operation - INCREMENT_USER_ENTITY_DATA
*
* @param entityId The id of the entity to update
* @param data The entity's data object
* @param callback The callback object
*/
brainCloudClient.entity.incrementUserEntityData = function(entityId, data, callback)
{
    var message = {
        entityId : entityId,
        data : data
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_INCREMENT_USER_ENTITY_DATA,
        data : message,
        callback : callback
    });
};

/**
* Partial increment of entity data field items. Partial set of items incremented as specified.
*
* Service Name - entity
* Service Operation - INCREMENT_SHARED_USER_ENTITY_DATA
*
* @param entityId The id of the entity to update
* @param targetProfileId Profile ID of the entity owner
* @param data The entity's data object
* @param callback The callback object
*/
brainCloudClient.entity.incrementSharedUserEntityData = function(entityId, targetProfileId, data, callback)
{
    var message = {
        entityId : entityId,
        targetPlayerId : targetProfileId,
        data : data
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_ENTITY,
        operation : brainCloudClient.entity.OPERATION_INCREMENT_SHARED_USER_ENTITY_DATA,
        data : message,
        callback : callback
    });
};

brainCloudClient.event = {};

brainCloudClient.SERVICE_EVENT = "event";

brainCloudClient.event.OPERATION_SEND = "SEND";
brainCloudClient.event.OPERATION_UPDATE_EVENT_DATA = "UPDATE_EVENT_DATA";
brainCloudClient.event.OPERATION_DELETE_INCOMING = "DELETE_INCOMING";
brainCloudClient.event.OPERATION_DELETE_SENT = "DELETE_SENT";
brainCloudClient.event.OPERATION_GET_EVENTS = "GET_EVENTS";


/**
 * Sends an event to the designated player id with the attached json data.
 * Any events that have been sent to a player will show up in their
 * incoming event mailbox. If the in_recordLocally flag is set to true,
 * a copy of this event (with the exact same event id) will be stored
 * in the sending player's "sent" event mailbox.
 *
 * Note that the list of sent and incoming events for a player is returned
 * in the "ReadPlayerState" call (in the BrainCloudPlayer module).
 *
 * Service Name - Event
 * Service Operation - Send
 *
 * @param toProfileId The id of the user who is being sent the event
 * @param eventType The user-defined type of the event.
 * @param eventData The user-defined data for this event encoded in JSON.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.event.sendEvent = function(toProfileId, eventType, eventData, callback) {
    var message = {
        toId: toProfileId,
        eventType: eventType,
        eventData: eventData
    };

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_EVENT,
        operation: brainCloudClient.event.OPERATION_SEND,
        data: message,
        callback: callback
    });
};

/**
 * Updates an event in the player's incoming event mailbox.
 *
 * Service Name - Event
 * Service Operation - UpdateEventData
 *
 * @param evId The event id
 * @param eventData The user-defined data for this event encoded in JSON.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.event.updateIncomingEventData = function(evId, eventData, callback) {
    var message = {
        evId: evId,
        eventData: eventData
    };
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_EVENT,
        operation: brainCloudClient.event.OPERATION_UPDATE_EVENT_DATA,
        data: message,
        callback: callback
    });
};

/**
 * Delete an event out of the user's incoming mailbox.
 *
 * Service Name - Event
 * Service Operation - DeleteIncoming
 *
 * @param evId The event id
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.event.deleteIncomingEvent = function(evId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_EVENT,
        operation: brainCloudClient.event.OPERATION_DELETE_INCOMING,
        data: {
            evId: evId
        },
        callback: callback
    });
};

/**
 * Get the events currently queued for the user.
 *
 * Service Name - Event
 * Service Operation - GetEvents
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.event.getEvents = function(callback) {
    brainCloudManager.sendRequest({
            service: brainCloudClient.SERVICE_EVENT,
            operation: brainCloudClient.event.OPERATION_GET_EVENTS,
            data: null,
            callback: callback
    });
};

brainCloudClient.file = {};

brainCloudClient.SERVICE_FILE = "file";

brainCloudClient.file.OPERATION_PREPARE_USER_UPLOAD = "PREPARE_USER_UPLOAD";
brainCloudClient.file.OPERATION_LIST_USER_FILES = "LIST_USER_FILES";
brainCloudClient.file.OPERATION_DELETE_USER_FILES = "DELETE_USER_FILES";
brainCloudClient.file.OPERATION_GET_CDN_URL = "GET_CDN_URL";

/**
 * Prepares a user file upload. On success an uploadId will be returned which
 * can be used to upload the file using the brainCloudClient.file.uploadFile method.
 *
 * @param cloudPath The desired cloud path of the file
 * @param cloudFilename The desired cloud filename of the file
 * @param shareable True if the file is shareable.
 * @param replaceIfExists Whether to replace file if it exists
 * @param fileSize The size of the file in bytes
 * @param callback The method to be invoked when the server response is received
 *
 * Significant error codes:
 *
 * 40429 - File maximum file size exceeded
 * 40430 - File exists, replaceIfExists not set
 */
brainCloudClient.file.prepareFileUpload = function(cloudPath, cloudFilename, shareable, replaceIfExists, fileSize, callback) {

    var message = {
        cloudPath : cloudPath,
        cloudFilename : cloudFilename,
        shareable : shareable,
        replaceIfExists : replaceIfExists,
        fileSize : fileSize
        // not used in js -- localPath : localPath
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_FILE,
        operation : brainCloudClient.file.OPERATION_PREPARE_USER_UPLOAD,
        data : message,
        callback : callback
    });
};

/**
 * Method uploads the supplied file to the brainCloud server. Note that you must
 * call prepareFileUpload to retrieve the uploadId before calling this method.
 * It is assumed that any methods required to monitor the file upload including
 * progress, and completion are attached to the XMLHttpRequest xhr object's
 * events such as:
 *
 * xhr.upload.addEventListener("progress", uploadProgress);
 * xhr.addEventListener("load", transferComplete);
 * xhr.addEventListener("error", transferFailed);
 * xhr.addEventListener("abort", transferCanceled);
 *
 * @param xhr The XMLHttpRequest object that the brainCloud client will
 * use to upload the file.
 * @param file The file object
 * @param uploadId The upload id obtained via prepareFileUpload()
 */
brainCloudClient.file.uploadFile = function(xhr, file, uploadId) {

    var url = brainCloudManager.getFileUploadUrl();
    var fd = new FormData();
    var fileSize = file.size;

    xhr.open("POST", url, true);
    fd.append("sessionId", brainCloudManager.getSessionId());
    fd.append("uploadId", uploadId);
    fd.append("fileSize", fileSize);
    fd.append("uploadFile", file);
    xhr.send(fd);
};

/**
 * List user files from the given cloud path
 *
 * @param cloudPath Optional - cloud path
 * @param recurse Optional - whether to recurse into sub-directories
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.file.listUserFiles = function(cloudPath, recurse, callback) {

    var message = {};

    if (cloudPath != null) {
        message.cloudPath = cloudPath;
    }
    if (recurse != null) {
        message.recurse = recurse;
    }

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_FILE,
        operation : brainCloudClient.file.OPERATION_LIST_USER_FILES,
        data : message,
        callback : callback
    });
};


/**
 * Deletes a single user file.
 *
 * @param cloudPath File path
 * @param cloudFilename name of file
 * @param callback The method to be invoked when the server response is received
 *
 * Significant error codes:
 *
 * 40431 - Cloud storage service error
 * 40432 - File does not exist
 *
 */
brainCloudClient.file.deleteUserFile = function(cloudPath, cloudFilename, callback) {
    var message = {
        cloudPath : cloudPath,
        cloudFilename : cloudFilename
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_FILE,
        operation : brainCloudClient.file.OPERATION_DELETE_USER_FILES,
        data : message,
        callback : callback
    });
};

/**
 * Delete multiple user files
 *
 * @param cloudPath File path
 * @param recurse Whether to recurse into sub-directories
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.file.deleteUserFiles = function(cloudPath, recurse, callback) {
    var message = {
        cloudPath : cloudPath,
        recurse : recurse
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_FILE,
        operation : brainCloudClient.file.OPERATION_DELETE_USER_FILES,
        data : message,
        callback : callback
    });
};

/**
* Returns the CDN url for a file object
*
* @param cloudPath File path
* @param cloudFileName File name
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.file.getCDNUrl = function(cloudPath, cloudFilename, callback) {
    var message = {
        cloudPath : cloudPath,
        cloudFilename : cloudFilename
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_FILE,
        operation : brainCloudClient.file.OPERATION_GET_CDN_URL,
        data : message,
        callback : callback
    });
};

brainCloudClient.friend = {};

brainCloudClient.SERVICE_FRIEND = "friend";

brainCloudClient.friend.OPERATION_GET_FRIEND_PROFILE_INFO_FOR_EXTERNAL_ID = "GET_FRIEND_PROFILE_INFO_FOR_EXTERNAL_ID";
brainCloudClient.friend.OPERATION_GET_PROFILE_INFO_FOR_CREDENTIAL = "GET_PROFILE_INFO_FOR_CREDENTIAL";
brainCloudClient.friend.OPERATION_GET_PROFILE_INFO_FOR_EXTERNAL_AUTH_ID = "GET_PROFILE_INFO_FOR_EXTERNAL_AUTH_ID";
brainCloudClient.friend.OPERATION_GET_EXTERNAL_ID_FOR_PROFILE_ID = "GET_EXTERNAL_ID_FOR_PROFILE_ID";
brainCloudClient.friend.OPERATION_READ_FRIENDS = "READ_FRIENDS";
brainCloudClient.friend.OPERATION_READ_FRIEND_ENTITY = "READ_FRIEND_ENTITY";
brainCloudClient.friend.OPERATION_READ_FRIENDS_ENTITIES = "READ_FRIENDS_ENTITIES";
brainCloudClient.friend.OPERATION_READ_FRIEND_PLAYER_STATE = "READ_FRIEND_PLAYER_STATE";
brainCloudClient.friend.OPERATION_READ_FRIENDS_WITH_APPLICATION = "READ_FRIENDS_WITH_APPLICATION";
brainCloudClient.friend.OPERATION_FIND_PLAYER_BY_NAME = "FIND_PLAYER_BY_NAME";
brainCloudClient.friend.OPERATION_FIND_PLAYER_BY_UNIVERSAL_ID = "FIND_PLAYER_BY_UNIVERSAL_ID";
brainCloudClient.friend.OPERATION_LIST_FRIENDS = "LIST_FRIENDS";
brainCloudClient.friend.OPERATION_ADD_FRIENDS = "ADD_FRIENDS";
brainCloudClient.friend.OPERATION_REMOVE_FRIENDS = "REMOVE_FRIENDS";
brainCloudClient.friend.OPERATION_GET_SUMMARY_DATA_FOR_PROFILE_ID = "GET_SUMMARY_DATA_FOR_PROFILE_ID";
brainCloudClient.friend.OPERATION_GET_USERS_ONLINE_STATUS = "GET_USERS_ONLINE_STATUS";
brainCloudClient.friend.OPERATION_FIND_USERS_BY_EXACT_NAME = "FIND_USERS_BY_EXACT_NAME";
brainCloudClient.friend.OPERATION_FIND_USERS_BY_SUBSTR_NAME = "FIND_USERS_BY_SUBSTR_NAME";

brainCloudClient.friend.friendPlatform = Object.freeze({ All : "All",  BrainCloud : "brainCloud",  Facebook : "Facebook" });

/**
 * Retrieves profile information for the specified user.
 *
 * Service Name - friend
 * Service Operation - GET_PROFILE_INFO_FOR_CREDENTIAL
 *
 * @param externalId The users's external ID
 * @param authenticationType The authentication type of the user ID
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.friend.getProfileInfoForCredential = function(externalId, authenticationType, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_GET_PROFILE_INFO_FOR_CREDENTIAL,
        data : {
            externalId : externalId,
            authenticationType : authenticationType
        },
        callback: callback
    });
};

/**
 * Retrieves profile information for the specified external auth user.
 *
 * Service Name - friend
 * Service Operation - GET_PROFILE_INFO_FOR_EXTERNAL_AUTH_ID
 *
 * @param externalId External ID of the friend to find
 * @param externalAuthType The external authentication type used for this friend's external ID
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.friend.getProfileInfoForExternalAuthId = function(externalId, externalAuthType, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_GET_PROFILE_INFO_FOR_EXTERNAL_AUTH_ID,
        data : {
            externalId : externalId,
            externalAuthType : externalAuthType
        },
        callback: callback
    });
};

/**
* Retrieves the external ID for the specified user profile ID on the specified social platform.
*
* @param profileId user's Profile ID.
* @param authenticationType Associated authentication type.
*/
brainCloudClient.friend.getExternalIdForProfileId = function(profileId, authenticationType, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_GET_EXTERNAL_ID_FOR_PROFILE_ID,
        data : {
            profileId : profileId,
            authenticationType : authenticationType
        },
        callback: callback
    });
};

/**
* Returns a particular entity of a particular friend.
*
* Service Name - friend
* Service Operation - ReadFriendEntity
*
* @param friendId Profile Id of friend who owns entity.
* @param entityId Id of entity to retrieve.
* @param callback Method to be invoked when the server response is received.
*
*/
brainCloudClient.friend.readFriendEntity = function(friendId, entityId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_READ_FRIEND_ENTITY,
        data: {
            friendId: friendId,
            entityId: entityId
        },
        callback: callback
    });
};

/**
* Returns entities of all friends optionally based on type.
*
* Service Name - friend
* Service Operation - ReadFriendsEntities
*
* @param entityType Types of entities to retrieve.
* @param callback Method to be invoked when the server response is received.
*
*/
brainCloudClient.friend.readFriendsEntities = function(entityType, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_READ_FRIENDS_ENTITIES,
        data: {
            entityType: entityType
        },
        callback: callback
    });
};

/**
* Read a friend's state.
*
* Service Name - PlayerState
* Service Operation - ReadFriendsPlayerState
*
* @param friendId Target friend
* @param callback Method to be invoked when the server response is received.
*/
brainCloudClient.friend.readFriendPlayerState = function(friendId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_READ_FRIEND_PLAYER_STATE,
        data: {
            friendId: friendId
        },
        callback: callback
    });
};

/**
* Finds a list of users matching the search text by performing an exact match search
*
* Service Name - friend
* Service Operation - FIND_USERS_BY_EXACT_NAME
*
* @param searchText The string to search for.
* @param maxResults  Maximum number of results to return.
* @param callback Method to be invoked when the server response is received.
*/
brainCloudClient.friend.findUsersByExactName = function(searchText, maxResults, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_FIND_USERS_BY_EXACT_NAME,
        data: {
            searchText: searchText,
            maxResults: maxResults
        },
        callback: callback
    });
};

/**
* Finds a list of users matching the search text by performing a substring
* search of all user names.
*
* Service Name - friend
* Service Operation - FIND_USERS_BY_SUBSTR_NAME
*
* @param searchText The substring to search for. Minimum length of 3 characters.
* @param maxResults  Maximum number of results to return. If there are more the message
* @param callback Method to be invoked when the server response is received.
*/
brainCloudClient.friend.findUsersBySubstrName = function(searchText, maxResults, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_FIND_USERS_BY_SUBSTR_NAME,
        data: {
            searchText: searchText,
            maxResults: maxResults
        },
        callback: callback
    });
};

/**
 * @deprecated Use findUserByUniversalId instead - Removal after September 1 2017
 */
brainCloudClient.friend.findPlayerByUniversalId = function(searchText, maxResults, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_FIND_PLAYER_BY_UNIVERSAL_ID,
        data: {
            searchText: searchText,
            maxResults: maxResults
        },
        callback: callback
    });
};

/**
 * Retrieves profile information for the partial matches of the specified text.
 *
 * @param searchText Universal ID text on which to search.
 * @param maxResults Maximum number of results to return.
 */
brainCloudClient.friend.findUserByUniversalId = function(searchText, maxResults, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_FIND_PLAYER_BY_UNIVERSAL_ID,
        data: {
            searchText: searchText,
            maxResults: maxResults
        },
        callback: callback
    });
};

/**
 * Retrieves a list of user and friend platform information for all friends of the current user.
 *
 * Service Name - friend
 * Service Operation - LIST_FRIENDS
 *
 * @param friendPlatform Friend platform to query.
 * @param includeSummaryData  True if including summary data; false otherwise.
 * @param in_callback Method to be invoked when the server response is received.
 */
brainCloudClient.friend.listFriends = function(friendPlatform, includeSummaryData, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_LIST_FRIENDS,
        data: {
            friendPlatform: friendPlatform,
            includeSummaryData: includeSummaryData
        },
        callback: callback
    });
};

/**
 * Links the current user and the specified users as brainCloud friends.
 *
 * Service Name - friend
 * Service Operation - ADD_FRIENDS
 *
 * @param profileIds Collection of profile IDs.
 * @param in_callback Method to be invoked when the server response is received.
 */
brainCloudClient.friend.addFriends = function(profileIds, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_ADD_FRIENDS,
        data: {
            profileIds: profileIds
        },
        callback: callback
    });
};

/**
* Unlinks the current user and the specified user profiles as brainCloud friends.
*
* Service Name - friend
* Service Operation - REMOVE_FRIENDS
*
* @param profileIds Collection of profile IDs.
* @param in_callback Method to be invoked when the server response is received.
*/
brainCloudClient.friend.removeFriends = function(profileIds, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_REMOVE_FRIENDS,
        data: {
            profileIds: profileIds
        },
        callback: callback
    });
};

/**
 * Returns state of a particular user.
 *
 * @param profileId Profile Id of user to retrieve user state for.
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.friend.getSummaryDataForProfileId = function(profileId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_GET_SUMMARY_DATA_FOR_PROFILE_ID,
        data: {
            profileId: profileId
        },
        callback: callback
    });
};

/**
* Get users online status
*
* Service Name - friend
* Service Operation - GET_USERS_ONLINE_STATUS
*
* @param profileIds Collection of profile IDs.
* @param callback Method to be invoked when the server response is received.
*/
brainCloudClient.friend.getUsersOnlineStatus  = function(profileIds, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_FRIEND,
        operation: brainCloudClient.friend.OPERATION_GET_USERS_ONLINE_STATUS,
        data: {
            profileIds: profileIds
        },
        callback: callback
    });
};

brainCloudClient.gamification = {};

brainCloudClient.gamification.SERVICE_GAMIFICATION = "gamification";

brainCloudClient.gamification.OPERATION_READ = "READ";
brainCloudClient.gamification.OPERATION_READ_XP_LEVELS = "READ_XP_LEVELS";
brainCloudClient.gamification.OPERATION_READ_ACHIEVEMENTS = "READ_ACHIEVEMENTS";
brainCloudClient.gamification.OPERATION_READ_ACHIEVED_ACHIEVEMENTS = "READ_ACHIEVED_ACHIEVEMENTS";
brainCloudClient.gamification.OPERATION_AWARD_ACHIEVEMENTS = "AWARD_ACHIEVEMENTS";

brainCloudClient.gamification.OPERATION_READ_MILESTONES = "READ_MILESTONES";
brainCloudClient.gamification.OPERATION_READ_MILESTONES_BY_CATEGORY = "READ_MILESTONES_BY_CATEGORY";
brainCloudClient.gamification.OPERATION_READ_COMPLETED_MILESTONES = "READ_COMPLETED_MILESTONES";
brainCloudClient.gamification.OPERATION_READ_IN_PROGRESS_MILESTONES = "READ_IN_PROGRESS_MILESTONES";
brainCloudClient.gamification.OPERATION_RESET_MILESTONES = "RESET_MILESTONES";

brainCloudClient.gamification.OPERATION_READ_QUESTS = "READ_QUESTS";
brainCloudClient.gamification.OPERATION_READ_QUESTS_BY_CATEGORY = "READ_QUESTS_BY_CATEGORY";
brainCloudClient.gamification.OPERATION_READ_COMPLETED_QUESTS = "READ_COMPLETED_QUESTS";
brainCloudClient.gamification.OPERATION_READ_IN_PROGRESS_QUESTS = "READ_IN_PROGRESS_QUESTS";
brainCloudClient.gamification.OPERATION_READ_NOT_STARTED_QUESTS = "READ_NOT_STARTED_QUESTS";
brainCloudClient.gamification.OPERATION_READ_QUESTS_WITH_STATUS = "READ_QUESTS_WITH_STATUS";
brainCloudClient.gamification.OPERATION_READ_QUESTS_WITH_BASIC_PERCENTAGE = "READ_QUESTS_WITH_BASIC_PERCENTAGE";
brainCloudClient.gamification.OPERATION_READ_QUESTS_WITH_COMPLEX_PERCENTAGE = "READ_QUESTS_WITH_COMPLEX_PERCENTAGE";


/**
 * Method retrieves all gamification data for the player.
 *
 * Service Name - Gamification
 * Service Operation - Read
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readAllGamification = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ,
        data: message,
        callback: callback
    });
};



/**
 * Method will award the achievements specified. On success, this will
 * call AwardThirdPartyAchievement to hook into the client-side Achievement
 * service (ie GameCentre, Facebook etc).
 *
 * Service Name - Gamification
 * Service Operation - AwardAchievements
 *
 * @param achievementIds An array of achievementId strings
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.awardAchievements = function(achievements, callback, includeMetaData) {
    message = {};
    message["achievements"] = achievements;

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_AWARD_ACHIEVEMENTS,
        data: message,
        callback: callback
    });
};


/**
 * Method retrives the list of achieved achievements.
 *
 * Service Name - Gamification
 * Service Operation - ReadAchievedAchievements
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readAchievedAchievements = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_ACHIEVED_ACHIEVEMENTS,
        data: message,
        callback: callback
    });
};

/**
 * Method returns all defined xp levels and any rewards associated
 * with those xp levels.
 *
 * Service Name - Gamification
 * Service Operation - ReadXpLevels
 *
 * @param callback {function} The callback handler
 */
brainCloudClient.gamification.readXPLevelsMetaData = function(callback) {
    message = {};

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_XP_LEVELS,
        callback: callback
    });
};

/**
 * Read all of the achievements defined for the game.
 *
 * Service Name - Gamification
 * Service Operation - ReadAchievements
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readAchievements = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_ACHIEVEMENTS,
        data: message,
        callback: callback
    });
};

/**
 * Method retrieves all milestones defined for the game.
 *
 * Service Name - Gamification
 * Service Operation - ReadMilestones
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readMilestones = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_MILESTONES,
        data: message,
        callback: callback
    });
};

/**
 * Method retrieves milestones of the given category.
 *
 * Service Name - Gamification
 * Service Operation - ReadMilestonesByCategory
 *
 * @param category The milestone category
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readMilestonesByCategory = function(category, callback, includeMetaData) {
    message = {};
    message["category"] = category;

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_MILESTONES_BY_CATEGORY,
        data: message,
        callback: callback
    });
};

/**
 * Method retrieves the list of completed milestones.
 *
 * Service Name - Gamification
 * Service Operation - ReadCompleteMilestones
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readCompletedMilestones = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_COMPLETED_MILESTONES,
        data: message,
        callback: callback
    });
};

/**
 * Method retrieves the list of in progress milestones
 *
 * Service Name - Gamification
 * Service Operation - ReadInProgressMilestones
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readInProgressMilestones = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_IN_PROGRESS_MILESTONES,
        data: message,
        callback: callback
    });
};

/**
* Resets the specified milestones' statuses to LOCKED.
*
* Service Name - Gamification
* Service Operation - ResetMilestones
*
* @param milestoneIds Comma separate list of milestones to reset
* @param callback Method to be invoked when the server response is received.
*/
brainCloudClient.gamification.resetMilestones = function(milestones, callback, includeMetaData) {
    message = {};
    message["milestones"] = milestones;

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_RESET_MILESTONES,
        data: message,
        callback: callback
    });
};


/**
 * Method retrieves all of the quests defined for the game.
 *
 * Service Name - Gamification
 * Service Operation - ReadQuests
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readQuests = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_QUESTS,
        data: message,
        callback: callback
    });
};

/**
 * Method returns quests for the given category.
 *
 * Service Name - Gamification
 * Service Operation - ReadQuestsByCategory
 *
 * @param category The quest category
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readQuestsByCategory = function(category, callback, includeMetaData) {
    message = {};
    message["category"] = category;

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_QUESTS_BY_CATEGORY,
        data: message,
        callback: callback
    });
};

/**
 *  Method returns all completed quests.
 *
 * Service Name - Gamification
 * Service Operation - ReadCompletedQuests
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readCompletedQuests = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_COMPLETED_QUESTS,
        data: message,
        callback: callback
    });
};

/**
 *  Method returns quests that are in progress.
 *
 * Service Name - Gamification
 * Service Operation - ReadInProgressQuests
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readInProgressQuests = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_IN_PROGRESS_QUESTS,
        data: message,
        callback: callback
    });
};

/**
 *  Method returns quests that have not been started.
 *
 * Service Name - Gamification
 * Service Operation - ReadNotStartedQuests
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readNotStartedQuests = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_NOT_STARTED_QUESTS,
        data: message,
        callback: callback
    });
};

/**
 *  Method returns quests with a status.
 *
 * Service Name - Gamification
 * Service Operation - ReadQuestsWithStatus
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readQuestsWithStatus = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_QUESTS_WITH_STATUS,
        data: message,
        callback: callback
    });
};

/**
 *  Method returns quests with a basic percentage.
 *
 * Service Name - Gamification
 * Service Operation - ReadQuestsWithBasicPercentage
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readQuestsWithBasicPercentage = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_QUESTS_WITH_BASIC_PERCENTAGE,
        data: message,
        callback: callback
    });
};

/**
 *  Method returns quests with a complex percentage.
 *
 * Service Name - Gamification
 * Service Operation - ReadQuestsWithComplexPercentage
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.gamification.readQuestsWithComplexPercentage = function(callback, includeMetaData) {
    message = {};

    if (includeMetaData) {
        message["includeMetaData"] = includeMetaData;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.gamification.SERVICE_GAMIFICATION,
        operation: brainCloudClient.gamification.OPERATION_READ_QUESTS_WITH_COMPLEX_PERCENTAGE,
        data: message,
        callback: callback
    });
};


brainCloudClient.globalApp = {};

brainCloudClient.SERVICE_GLOBAL_APP = "globalApp";
brainCloudClient.globalApp.OPERATION_READ_PROPERTIES = "READ_PROPERTIES";

/**
 * Read game's global properties
 *
 * Service Name - GlobalApp
 * Service Operation - ReadProperties
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.globalApp.readProperties = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_APP,
        operation : brainCloudClient.globalApp.OPERATION_READ_PROPERTIES,
        callback : callback
    });
};

brainCloudClient.globalEntity = {};

brainCloudClient.SERVICE_GLOBAL_ENTITY = "globalEntity";

brainCloudClient.globalEntity.OPERATION_CREATE = "CREATE";
brainCloudClient.globalEntity.OPERATION_CREATE_WITH_INDEXED_ID = "CREATE_WITH_INDEXED_ID";
brainCloudClient.globalEntity.OPERATION_READ = "READ";
brainCloudClient.globalEntity.OPERATION_UPDATE = "UPDATE";
brainCloudClient.globalEntity.OPERATION_UPDATE_ACL = "UPDATE_ACL";
brainCloudClient.globalEntity.OPERATION_UPDATE_TIME_TO_LIVE = "UPDATE_TIME_TO_LIVE";
brainCloudClient.globalEntity.OPERATION_DELETE = "DELETE";
brainCloudClient.globalEntity.OPERATION_GET_LIST = "GET_LIST";
brainCloudClient.globalEntity.OPERATION_GET_LIST_BY_INDEXED_ID = "GET_LIST_BY_INDEXED_ID";
brainCloudClient.globalEntity.OPERATION_GET_LIST_COUNT = "GET_LIST_COUNT";
brainCloudClient.globalEntity.OPERATION_GET_PAGE = "GET_PAGE";
brainCloudClient.globalEntity.OPERATION_GET_PAGE_BY_OFFSET = "GET_PAGE_BY_OFFSET";
brainCloudClient.globalEntity.OPERATION_INCREMENT_GLOBAL_ENTITY_DATA = "INCREMENT_GLOBAL_ENTITY_DATA";
brainCloudClient.globalEntity.OPERATION_UPDATE_ENTITY_OWNER_AND_ACL = "UPDATE_ENTITY_OWNER_AND_ACL";
brainCloudClient.globalEntity.OPERATION_MAKE_SYSTEM_ENTITY = "MAKE_SYSTEM_ENTITY";

/**
* Method creates a new entity on the server.
*
* Service Name - globalEntity
* Service Operation - Create
*
* @param entityType The entity type as defined by the user
* @param timeToLive Sets expiry time for entity in milliseconds if > 0
* @param acl The entity's access control list as json. A null acl implies default
* @param data   The entity's data as a json string
* @param callback The callback object
*/
brainCloudClient.globalEntity.createEntity = function(entityType, timeToLive,
        acl, data, callback) {
    var message = {
        entityType : entityType,
        timeToLive : timeToLive,
        data : data
    };

    if (acl) {
        message["acl"] = acl;
    }

    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
                operation : brainCloudClient.globalEntity.OPERATION_CREATE,
                data : message,
                callback : callback
            });
};

/**
* Method creates a new entity on the server with an indexed id.
*
* Service Name - globalEntity
* Service Operation - CreateWithIndexedId
*
* @param entityType The entity type as defined by the user
* @param indexedId A secondary ID that will be indexed
* @param timeToLive Sets expiry time for entity in milliseconds if > 0
* @param acl The entity's access control list as json. A null acl implies default
* @param data   The entity's data as a json string
* @param callback The callback object
*/
brainCloudClient.globalEntity.createEntityWithIndexedId = function(entityType,
        indexedId, timeToLive, acl, data, callback) {
    var message = {
        entityType : entityType,
        entityIndexedId : indexedId,
        timeToLive : timeToLive,
        data : data
    };

    if (acl) {
        message["acl"] = acl;
    }

    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
                operation : brainCloudClient.globalEntity.OPERATION_CREATE_WITH_INDEXED_ID,
                data : message,
                callback : callback
            });
};

/**
* Method deletes an existing entity on the server.
*
* Service Name - globalEntity
* Service Operation - Delete
*
* @param entityId The entity ID
* @param version The version of the entity to delete
* @param callback The callback object
*/
brainCloudClient.globalEntity.deleteEntity = function(entityId, version,
        callback) {
    var message = {
        entityId : entityId,
        version : version
    };

    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
                operation : brainCloudClient.globalEntity.OPERATION_DELETE,
                data : message,
                callback : callback
            });
};

/**
* Method gets list of entities from the server base on type and/or where clause
*
* Service Name - globalEntity
* Service Operation - GetList
*
* @param where Mongo style query string
* @param orderBy Sort order
* @param maxReturn The maximum number of entities to return
* @param callback The callback object
*/
brainCloudClient.globalEntity.getList = function(where, orderBy, maxReturn,
    callback) {
    var message = {
    where : where,
    maxReturn : maxReturn
    };

    if (orderBy) {
    message["orderBy"] = orderBy;
    }

    brainCloudManager
        .sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
        operation : brainCloudClient.globalEntity.OPERATION_GET_LIST,
        data : message,
        callback : callback
        });
};

/**
* Method gets list of entities from the server base on indexed id
*
* Service Name - globalEntity
* Service Operation - GetListByIndexedId
*
* @param entityIndexedId The entity indexed Id
* @param maxReturn The maximum number of entities to return
* @param callback The callback object
*/
brainCloudClient.globalEntity.getListByIndexedId = function(entityIndexedId,
    maxReturn, callback) {
    var message = {
    entityIndexedId : entityIndexedId,
    maxReturn : maxReturn
    };

    brainCloudManager
        .sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
        operation : brainCloudClient.globalEntity.OPERATION_GET_LIST_BY_INDEXED_ID,
        data : message,
        callback : callback
        });
};

/**
* Method gets a count of entities based on the where clause
*
* Service Name - globalEntity
* Service Operation - GetListCount
*
* @param where Mongo style query string
* @param callback The callback object
*/
brainCloudClient.globalEntity.getListCount = function(where, callback) {
    var message = {
    where : where
    };

    brainCloudManager
        .sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
        operation : brainCloudClient.globalEntity.OPERATION_GET_LIST_COUNT,
        data : message,
        callback : callback
        });
};

/**
* Method reads an existing entity from the server.
*
* Service Name - globalEntity
* Service Operation - Read
*
* @param entityId The entity ID
* @param callback The callback object
*/
brainCloudClient.globalEntity.readEntity = function(entityId, callback) {
    var message = {
    entityId : entityId
    };

    brainCloudManager.sendRequest({
    service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
    operation : brainCloudClient.globalEntity.OPERATION_READ,
    data : message,
    callback : callback
    });
};

/**
* Method updates an existing entity on the server.
*
* Service Name - globalEntity
* Service Operation - UPDATE
*
* @param entityId The entity ID
* @param version The version of the entity to update
* @param data   The entity's data as a json string
* @param callback The callback object
*/
brainCloudClient.globalEntity.updateEntity = function(entityId, version, data, callback) {
    var message = {
        entityId : entityId
    };

    if(typeof version === "number") {
        message.version = version;
        message.data = data;
    }
    else {
        message.version = data;
        message.data = version;
    }

    brainCloudManager
        .sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
        operation : brainCloudClient.globalEntity.OPERATION_UPDATE,
        data : message,
        callback : callback
        });
};

/**
* Method updates an existing entity's Acl on the server.
*
* Service Name - globalEntity
* Service Operation - UpdateAcl
*
* @param entityId The entity ID
* @param acl The entity's access control list as json.
* @param version The version of the entity to update
* @param callback The callback object
*/
brainCloudClient.globalEntity.updateEntityAcl = function(entityId, acl,
    version, callback) {
    var message = {
    entityId : entityId,
    version : version,
    acl : acl
    };

    brainCloudManager
        .sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
        operation : brainCloudClient.globalEntity.OPERATION_UPDATE_ACL,
        data : message,
        callback : callback
        });
};

/**
* Method updates an existing entity's time to live on the server.
*
* Service Name - globalEntity
* Service Operation - UpdateTimeToLive
*
* @param entityId The entity ID
* @param timeToLive Sets expiry time for entity in milliseconds if > 0
* @param version The version of the entity to update
* @param callback The callback object
*/
brainCloudClient.globalEntity.updateEntityUpdateTimeToLive = function(entityId,
    timeToLive, version, callback) {
    var message = {
    entityId : entityId,
    version : version,
    timeToLive : timeToLive
    };

    brainCloudManager
        .sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
        operation : brainCloudClient.globalEntity.OPERATION_UPDATE_TIME_TO_LIVE,
        data : message,
        callback : callback
        });
};

/**
 * Method uses a paging system to iterate through Global Entities
 * After retrieving a page of Global Entities with this method,
 * use GetPageOffset() to retrieve previous or next pages.
 *
 * Service Name - globalEntity
 * Service Operation - GetPage
 *
 * @param context The json context for the page request.
 *                   See the portal appendix documentation for format.
 * @param callback The callback object
 */
brainCloudClient.globalEntity.getPage = function(context, callback) {
    var message = {
    context : context
    };

    brainCloudManager
        .sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
        operation : brainCloudClient.globalEntity.OPERATION_GET_PAGE,
        data : message,
        callback : callback
        });
};

/**
 * Method to retrieve previous or next pages after having called the GetPage method.
 *
 * Service Name - globalEntity
 * Service Operation - GetPageOffset
 *
 * @param context The context string returned from the server from a
 *      previous call to GetPage or GetPageOffset
 * @param pageOffset The positive or negative page offset to fetch. Uses the last page
 *      retrieved using the context string to determine a starting point.
 * @param callback The callback object
 */
brainCloudClient.globalEntity.getPageOffset = function(context, pageOffset,
    callback) {
    var message = {
    context : context,
    pageOffset : pageOffset
    };

    brainCloudManager
        .sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
        operation : brainCloudClient.globalEntity.OPERATION_GET_PAGE_BY_OFFSET,
        data : message,
        callback : callback
        });
};

/**
* Partial increment of global entity data field items. Partial set of items incremented as specified.
*
* Service Name - globalEntity
* Service Operation - INCREMENT_GLOBAL_ENTITY_DATA
*
* @param entityId The id of the entity to update
* @param data The entity's data object
* @param callback The callback object
*/
brainCloudClient.globalEntity.incrementGlobalEntityData = function(entityId, data, callback)
{
    var message = {
        entityId : entityId,
        data : data
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
        operation : brainCloudClient.globalEntity.OPERATION_INCREMENT_GLOBAL_ENTITY_DATA,
        data : message,
        callback : callback
    });
};

/**
 * Method updates an existing entity's Owner and ACL on the server.
 *
 * Service Name - globalEntity
 * Service Operation - UPDATE_ENTITY_OWNER_AND_ACL
 *
 * @param entityId The entity ID
 * @param version The version of the entity to update
 * @param ownerId The owner ID
 * @param acl The entity's access control list
 * @param callback The callback object
 */
 brainCloudClient.globalEntity.updateEntityOwnerAndAcl = function(entityId, version, ownerId, acl, callback)
 {
     var message = {
         entityId : entityId,
         version : version,
         ownerId: ownerId,
         acl : acl
     };

     brainCloudManager.sendRequest({
         service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
         operation : brainCloudClient.globalEntity.OPERATION_UPDATE_ENTITY_OWNER_AND_ACL,
         data : message,
         callback : callback
     });
 };

/**
 * Method clears the owner id of an existing entity and sets the ACL on the server.
 *
 * Service Name - globalEntity
 * Service Operation - MAKE_SYSTEM_ENTITY
 *
 * @param entityId The entity ID
 * @param version The version of the entity to update
 * @param acl The entity's access control list
 * @param callback The callback object
 */
brainCloudClient.globalEntity.makeSystemEntity = function(entityId, version, acl, callback)
{
    var message = {
        entityId : entityId,
        version : version,
        acl : acl
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_ENTITY,
        operation : brainCloudClient.globalEntity.OPERATION_MAKE_SYSTEM_ENTITY,
        data : message,
        callback : callback
    });
};
/**
 * @status - incomplete - see STUB
 */

brainCloudClient.globalStatistics = {};

brainCloudClient.SERVICE_GLOBAL_GAME_STATISTICS = "globalGameStatistics";

brainCloudClient.globalStatistics.OPERATION_READ = "READ";
brainCloudClient.globalStatistics.OPERATION_READ_SUBSET = "READ_SUBSET";
brainCloudClient.globalStatistics.OPERATION_READ_FOR_CATEGORY = "READ_FOR_CATEGORY";
brainCloudClient.globalStatistics.OPERATION_UPDATE_INCREMENT = "UPDATE_INCREMENT";
brainCloudClient.globalStatistics.OPERATION_PROCESS_STATISTICS = "PROCESS_STATISTICS";

/**
 * Atomically increment (or decrement) global statistics.
 * Global statistics are defined through the brainCloud portal.
 *
 * Service Name - GlobalStatistics
 * Service Operation - UpdateIncrement
 *
 * @param stats The JSON encoded data to be sent to the server as follows:
 * {
 *   stat1: 10,
 *   stat2: -5.5,
 * }
 * would increment stat1 by 10 and decrement stat2 by 5.5.
 * For the full statistics grammar see the api.braincloudservers.com site.
 * There are many more complex operations supported such as:
 * {
 *   stat1:INC_TO_LIMIT#9#30
 * }
 * which increments stat1 by 9 up to a limit of 30.
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.globalStatistics.incrementGlobalStats = function(stats,
        callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_GLOBAL_GAME_STATISTICS,
                operation : brainCloudClient.globalStatistics.OPERATION_UPDATE_INCREMENT,
                data : {
                    statistics : stats
                },
                callback : callback
            });
};

/**
 * Method returns all of the global statistics.
 *
 * Service Name - GlobalStatistics
 * Service Operation - Read
 *
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.globalStatistics.readAllGlobalStats = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_GAME_STATISTICS,
        operation : brainCloudClient.globalStatistics.OPERATION_READ,
        callback : callback
    });
};

/**
 * Reads a subset of global statistics as defined by the input JSON.
 *
 * Service Name - GlobalStatistics
 * Service Operation - ReadSubset
 *
 * @param stats The json data containing an array of statistics to read:
 * [
 *   "Level01_TimesBeaten",
 *   "Level02_TimesBeaten"
 * ]
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.globalStatistics.readGlobalStatsSubset = function(stats,
        callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_GAME_STATISTICS,
        operation : brainCloudClient.globalStatistics.OPERATION_READ_SUBSET,
        data : {
            statistics : stats
        },
        callback : callback
    });
};


/**
* Method retrieves the global statistics for the given category.
*
* Service Name - GlobalStatistics
* Service Operation - READ_FOR_CATEGORY
*
* @param category The global statistics category
* @param callback Method to be invoked when the server response is received.
*/
brainCloudClient.globalStatistics.readGlobalStatsForCategory = function(category, callback) {
   brainCloudManager.sendRequest({
       service: brainCloudClient.SERVICE_GLOBAL_GAME_STATISTICS,
       operation: brainCloudClient.globalStatistics.OPERATION_READ_FOR_CATEGORY,
       data: {
           category: category
       },
       callback: callback
   });
};

/**
* Apply statistics grammar to a partial set of statistics.
*
* Service Name - PlayerStatistics
* Service Operation - PROCESS_STATISTICS
*
* @param jsonData The JSON format is as follows:
* {
*     "DEAD_CATS": "RESET",
*     "LIVES_LEFT": "SET#9",
*     "MICE_KILLED": "INC#2",
*     "DOG_SCARE_BONUS_POINTS": "INC#10",
*     "TREES_CLIMBED": 1
* }
* @param callback Method to be invoked when the server response is received.
*/
brainCloudClient.globalStatistics.processStatistics = function(stats, callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GLOBAL_GAME_STATISTICS,
        operation : brainCloudClient.globalStatistics.OPERATION_PROCESS_STATISTICS,
        data : {
            statistics : stats
        },
        callback : callback
    });
};
brainCloudClient.group = {};

brainCloudClient.SERVICE_GROUP = "group";

brainCloudClient.group.OPERATION_ACCEPT_GROUP_INVITATION = "ACCEPT_GROUP_INVITATION";
brainCloudClient.group.OPERATION_ADD_GROUP_MEMBER = "ADD_GROUP_MEMBER";
brainCloudClient.group.OPERATION_APPROVE_GROUP_JOIN_REQUEST = "APPROVE_GROUP_JOIN_REQUEST";
brainCloudClient.group.OPERATION_AUTO_JOIN_GROUP = "AUTO_JOIN_GROUP";
brainCloudClient.group.OPERATION_CANCEL_GROUP_INVITATION = "CANCEL_GROUP_INVITATION";
brainCloudClient.group.OPERATION_CREATE_GROUP = "CREATE_GROUP";
brainCloudClient.group.OPERATION_CREATE_GROUP_ENTITY = "CREATE_GROUP_ENTITY";
brainCloudClient.group.OPERATION_DELETE_GROUP = "DELETE_GROUP";
brainCloudClient.group.OPERATION_DELETE_GROUP_ENTITY = "DELETE_GROUP_ENTITY";
brainCloudClient.group.OPERATION_DELETE_MEMBER_FROM_GROUP = "DELETE_MEMBER_FROM_GROUP";
brainCloudClient.group.OPERATION_GET_MY_GROUPS = "GET_MY_GROUPS";
brainCloudClient.group.OPERATION_INCREMENT_GROUP_DATA = "INCREMENT_GROUP_DATA";
brainCloudClient.group.OPERATION_INCREMENT_GROUP_ENTITY_DATA = "INCREMENT_GROUP_ENTITY_DATA";
brainCloudClient.group.OPERATION_INVITE_GROUP_MEMBER = "INVITE_GROUP_MEMBER";
brainCloudClient.group.OPERATION_JOIN_GROUP = "JOIN_GROUP";
brainCloudClient.group.OPERATION_LEAVE_GROUP = "LEAVE_GROUP";
brainCloudClient.group.OPERATION_LIST_GROUPS_PAGE = "LIST_GROUPS_PAGE";
brainCloudClient.group.OPERATION_LIST_GROUPS_PAGE_BY_OFFSET = "LIST_GROUPS_PAGE_BY_OFFSET";
brainCloudClient.group.OPERATION_LIST_GROUPS_WITH_MEMBER = "LIST_GROUPS_WITH_MEMBER";
brainCloudClient.group.OPERATION_READ_GROUP = "READ_GROUP";
brainCloudClient.group.OPERATION_READ_GROUP_DATA = "READ_GROUP_DATA";
brainCloudClient.group.OPERATION_READ_GROUP_ENTITIES_PAGE = "READ_GROUP_ENTITIES_PAGE";
brainCloudClient.group.OPERATION_READ_GROUP_ENTITIES_PAGE_BY_OFFSET = "READ_GROUP_ENTITIES_PAGE_BY_OFFSET";
brainCloudClient.group.OPERATION_READ_GROUP_ENTITY = "READ_GROUP_ENTITY";
brainCloudClient.group.OPERATION_READ_GROUP_MEMBERS = "READ_GROUP_MEMBERS";
brainCloudClient.group.OPERATION_REJECT_GROUP_INVITATION = "REJECT_GROUP_INVITATION";
brainCloudClient.group.OPERATION_REJECT_GROUP_JOIN_REQUEST = "REJECT_GROUP_JOIN_REQUEST";
brainCloudClient.group.OPERATION_REMOVE_GROUP_MEMBER = "REMOVE_GROUP_MEMBER";
brainCloudClient.group.OPERATION_UPDATE_GROUP_DATA = "UPDATE_GROUP_DATA";
brainCloudClient.group.OPERATION_UPDATE_GROUP_ENTITY = "UPDATE_GROUP_ENTITY_DATA";
brainCloudClient.group.OPERATION_UPDATE_GROUP_MEMBER = "UPDATE_GROUP_MEMBER";
brainCloudClient.group.OPERATION_UPDATE_GROUP_NAME = "UPDATE_GROUP_NAME";

// Constant helper values
brainCloudClient.group.role = Object.freeze({ owner : "OWNER", admin : "ADMIN", member : "MEMBER", other : "OTHER"});
brainCloudClient.group.autoJoinStrategy = Object.freeze({ joinFirstGroup : "JoinFirstGroup", joinRandomGroup : "JoinRandomGroup" });

/**
 * Accept an outstanding invitation to join the group.
 *
 * Service Name - group
 * Service Operation - ACCEPT_GROUP_INVITATION
 *
 * @param groupId ID of the group.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.acceptGroupInvitation = function(groupId, callback) {
    var message = {
        groupId : groupId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_ACCEPT_GROUP_INVITATION,
        data : message,
        callback : callback
    });
};

/**
 * Add a member to the group.
 *
 * Service Name - group
 * Service Operation - ADD_GROUP_MEMBER
 *
 * @param groupId ID of the group.
 * @param profileId Profile ID of the member being added.
 * @param role Role of the member being added.
 * @param attributes Attributes of the member being added.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.addGroupMember = function(groupId, profileId, role, attributes, callback) {
    var message = {
        groupId : groupId,
        profileId : profileId,
        role : role
    };

    if(attributes) message.attributes = attributes;

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_ADD_GROUP_MEMBER,
        data : message,
        callback : callback
    });
};

/**
 * Approve an outstanding request to join the group.
 *
 * Service Name - group
 * Service Operation - APPROVE_GROUP_JOIN_REQUEST
 *
 * @param groupId ID of the group.
 * @param profileId Profile ID of the invitation being deleted.
 * @param role Role of the member being invited.
 * @param attributes Attributes of the member being invited.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.approveGroupJoinRequest = function(groupId, profileId, role, attributes, callback) {
    var message = {
        groupId : groupId,
        profileId : profileId
    };

    if(role) message.role = role;
    if(attributes) message.attributes = attributes;

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_APPROVE_GROUP_JOIN_REQUEST,
        data : message,
        callback : callback
    });
};

/**
 * Automatically join an open group that matches the search criteria and has space available.
 *
 * Service Name - group
 * Service Operation - AUTO_JOIN_GROUP
 *
 * @param groupType Name of the associated group type.
 * @param autoJoinStrategy Selection strategy to employ when there are multiple matches
 * @param dataQueryJson Query parameters (optional)
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.autoJoinGroup = function(groupType, autoJoinStrategy, dataQueryJson, callback) {
    var message = {
        groupType : groupType,
        autoJoinStrategy : autoJoinStrategy
    };

    if(dataQueryJson) message.dataQueryJson = dataQueryJson;

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_AUTO_JOIN_GROUP,
        data : message,
        callback : callback
    });
};

/**
 * Cancel an outstanding invitation to the group.
 *
 * Service Name - group
 * Service Operation - CANCEL_GROUP_INVITATION
 *
 * @param groupId ID of the group.
 * @param profileId Profile ID of the invitation being deleted.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.cancelGroupInvitation = function(groupId, profileId, callback) {
    var message = {
        groupId : groupId,
        profileId : profileId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_CANCEL_GROUP_INVITATION,
        data : message,
        callback : callback
    });
};

/**
 * Create a group.
 *
 * Service Name - group
 * Service Operation - CREATE_GROUP
 *
 * @param name Name of the group.
 * @param groupType Name of the type of group.
 * @param isOpenGroup true if group is open; false if closed.
 * @param acl The group's access control list. A null ACL implies default.
 * @param ownerAttributes Attributes for the group owner (current member).
 * @param defaultMemberAttributes Default attributes for group members.
 * @param data Custom application data.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.createGroup = function(
    name,
    groupType,
    isOpenGroup,
    acl,
    data,
    ownerAttributes,
    defaultMemberAttributes,
    callback) {
    var message = {
        groupType : groupType
    };

    if(name) message.name = name;
    if(isOpenGroup) message.isOpenGroup = isOpenGroup;
    if(acl) message.acl = acl;
    if(data) message.data = data;
    if(ownerAttributes) message.ownerAttributes = ownerAttributes;
    if(defaultMemberAttributes) message.defaultMemberAttributes = defaultMemberAttributes;

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_CREATE_GROUP,
        data : message,
        callback : callback
    });
};

/**
 * Create a group entity.
 *
 * Service Name - group
 * Service Operation - CREATE_GROUP_ENTITY
 *
 * @param groupId ID of the group.
 * @param isOwnedByGroupMember true if entity is owned by a member; false if owned by the entire group.
 * @param entityType Type of the group entity.
 * @param acl Access control list for the group entity.
 * @param data Custom application data.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.createGroupEntity = function(
    groupId,
    entityType,
    isOwnedByGroupMember,
    acl,
    data,
    callback) {
    var message = {
        groupId : groupId
    };

    if(entityType) message.entityType = entityType;
    if(isOwnedByGroupMember) message.isOwnedByGroupMember = isOwnedByGroupMember;
    if(acl) message.acl = acl;
    if(data) message.data = data;

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_CREATE_GROUP_ENTITY,
        data : message,
        callback : callback
    });
};

/**
 * Delete a group.
 *
 * Service Name - group
 * Service Operation - DELETE_GROUP
 *
 * @param groupId ID of the group.
 * @param version Current version of the group
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.deleteGroup = function(groupId, version, callback) {
    var message = {
        groupId : groupId,
        version : version
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_DELETE_GROUP,
        data : message,
        callback : callback
    });
};

/**
 * Delete a group entity.
 *
 * Service Name - group
 * Service Operation - DELETE_GROUP_ENTITY
 *
 * @param groupId ID of the group.
 * @param entityId ID of the entity.
 * @param version The current version of the group entity (for concurrency checking).
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.deleteGroupEntity = function(groupId, entityId, version, callback) {
    var message = {
        groupId : groupId,
        entityId : entityId,
        version : version
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_DELETE_GROUP_ENTITY,
        data : message,
        callback : callback
    });
};

/**
 * Read information on groups to which the current user belongs.
 *
 * Service Name - group
 * Service Operation - GET_MY_GROUPS
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.getMyGroups = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_GET_MY_GROUPS,
        data : {},
        callback : callback
    });
};

/**
 * Increment elements for the group's data field.
 *
 * Service Name - group
 * Service Operation - INCREMENT_GROUP_DATA
 *
 * @param groupId ID of the group.
 * @param data Partial data map with incremental values.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.incrementGroupData = function(groupId, data, callback) {
    var message = {
        groupId : groupId,
        data : data
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_INCREMENT_GROUP_DATA,
        data : message,
        callback : callback
    });
};

/**
 * Increment elements for the group entity's data field.
 *
 * Service Name - group
 * Service Operation - INCREMENT_GROUP_ENTITY_DATA
 *
 * @param groupId ID of the group.
 * @param entityId ID of the entity.
 * @param data Partial data map with incremental values.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.incrementGroupEntityData = function(groupId, entityId, data, callback) {
    var message = {
        groupId : groupId,
        entityId : entityId,
        data : data
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_INCREMENT_GROUP_ENTITY_DATA,
        data : message,
        callback : callback
    });
};

/**
 * Invite a user to the group.
 *
 * Service Name - group
 * Service Operation - INVITE_GROUP_MEMBER
 *
 * @param groupId ID of the group.
 * @param profileId Profile ID of the member being invited.
 * @param role Role of the member being invited.
 * @param attributes Attributes of the member being invited.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.inviteGroupMember = function(groupId, profileId, role, attributes, callback) {
    var message = {
        groupId : groupId,
        profileId : profileId
    };

    if(role) message.role = role;
    if(attributes) message.attributes = attributes;

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_INVITE_GROUP_MEMBER,
        data : message,
        callback : callback
    });
};

/**
 * Join an open group or request to join a closed group.
 *
 * Service Name - group
 * Service Operation - JOIN_GROUP
 *
 * @param groupId ID of the group.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.joinGroup = function(groupId, callback) {
    var message = {
        groupId : groupId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_JOIN_GROUP,
        data : message,
        callback : callback
    });
};

/**
 * Leave a group in which the user is a member.
 *
 * Service Name - group
 * Service Operation - LEAVE_GROUP
 *
 * @param groupId ID of the group.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.leaveGroup = function(groupId, callback) {
    var message = {
        groupId : groupId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_LEAVE_GROUP,
        data : message,
        callback : callback
    });
};

/**
 * Read a page of group information.
 *
 * Service Name - group
 * Service Operation - LIST_GROUPS_PAGE
 *
 * @param context Query context.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.listGroupsPage = function(context, callback) {
    var message = {
        context : context
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_LIST_GROUPS_PAGE,
        data : message,
        callback : callback
    });
};

/**
 * Read a page of group information.
 *
 * Service Name - group
 * Service Operation - LIST_GROUPS_PAGE_BY_OFFSET
 *
 * @param encodedContext Encoded reference query context.
 * @param offset Number of pages by which to offset the query.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.listGroupsPageByOffset = function(encodedContext, pageOffset, callback) {
    var message = {
        context : encodedContext,
        pageOffset : pageOffset
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_LIST_GROUPS_PAGE_BY_OFFSET,
        data : message,
        callback : callback
    });
};

/**
 * Read information on groups to which the specified member belongs.  Access is subject to restrictions.
 *
 * Service Name - group
 * Service Operation - LIST_GROUPS_WITH_MEMBER
 *
 * @param profileId
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.listGroupsWithMember = function(profileId, callback) {
    var message = {
        profileId : profileId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_LIST_GROUPS_WITH_MEMBER,
        data : message,
        callback : callback
    });
};

/**
 * Read the specified group.
 *
 * Service Name - group
 * Service Operation - READ_GROUP
 *
 * @param groupId ID of the group.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.readGroup = function(groupId, callback) {
    var message = {
        groupId : groupId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_READ_GROUP,
        data : message,
        callback : callback
    });
};

/**
 * Read the data of the specified group.
 *
 * Service Name - group
 * Service Operation - READ_GROUP_DATA
 *
 * @param groupId ID of the group.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.readGroupData = function(groupId, callback) {
    var message = {
        groupId : groupId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_READ_GROUP_DATA,
        data : message,
        callback : callback
    });
};

/**
 * Read a page of group entity information.
 *
 * Service Name - group
 * Service Operation - READ_GROUP_ENTITIES_PAGE
 *
 * @param context Query context.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.readGroupEntitiesPage = function(context, callback) {
    var message = {
        context : context
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_READ_GROUP_ENTITIES_PAGE,
        data : message,
        callback : callback
    });
};

/**
 * Read a page of group entity information.
 *
 * Service Name - group
 * Service Operation - READ_GROUP_ENTITIES_PAGE_BY_OFFSET
 *
 * @param encodedContext Encoded reference query context.
 * @param offset Number of pages by which to offset the query.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.readGroupEntitiesPageByOffset = function(encodedContext, pageOffset, callback) {
    var message = {
        context : encodedContext,
        pageOffset : pageOffset
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_READ_GROUP_ENTITIES_PAGE_BY_OFFSET,
        data : message,
        callback : callback
    });
};

/**
 * Read the specified group entity.
 *
 * Service Name - group
 * Service Operation - READ_GROUP_ENTITY
 *
 * @param groupId ID of the group.
 * @param entityId ID of the entity.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.readGroupEntity = function(groupId, entityId, callback) {
    var message = {
        groupId : groupId,
        entityId : entityId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_READ_GROUP_ENTITY,
        data : message,
        callback : callback
    });
};

/**
 * Read the members of the group.
 *
 * Service Name - group
 * Service Operation - READ_MEMBERS_OF_GROUP
 *
 * @param groupId ID of the group.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.readGroupMembers = function(groupId, callback) {
    var message = {
        groupId : groupId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_READ_GROUP_MEMBERS,
        data : message,
        callback : callback
    });
};

/**
 * Reject an outstanding invitation to join the group.
 *
 * Service Name - group
 * Service Operation - REJECT_GROUP_INVITATION
 *
 * @param groupId ID of the group.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.rejectGroupInvitation = function(groupId, callback) {
    var message = {
        groupId : groupId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_REJECT_GROUP_INVITATION,
        data : message,
        callback : callback
    });
};

/**
 * Reject an outstanding request to join the group.
 *
 * Service Name - group
 * Service Operation - REJECT_GROUP_JOIN_REQUEST
 *
 * @param groupId ID of the group.
 * @param profileId Profile ID of the invitation being deleted.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.rejectGroupJoinRequest = function(groupId, profileId, callback) {
    var message = {
        groupId : groupId,
        profileId : profileId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_REJECT_GROUP_JOIN_REQUEST,
        data : message,
        callback : callback
    });
};

/**
 * Remove a member from the group.
 *
 * Service Name - group
 * Service Operation - REMOVE_GROUP_MEMBER
 *
 * @param groupId ID of the group.
 * @param profileId Profile ID of the member being deleted.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.removeGroupMember = function(groupId, profileId, callback) {
    var message = {
        groupId : groupId,
        profileId : profileId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_REMOVE_GROUP_MEMBER,
        data : message,
        callback : callback
    });
};

/**
 * Updates a group's data.
 *
 * Service Name - group
 * Service Operation - UPDATE_GROUP_DATA
 *
 * @param groupId ID of the group.
 * @param version Version to verify.
 * @param data Data to apply.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.updateGroupData = function(groupId, version, data, callback) {
    var message = {
        groupId : groupId,
        version : version,
        data : data
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_UPDATE_GROUP_DATA,
        data : message,
        callback : callback
    });
};

/**
 * Update a group entity.
 *
 * Service Name - group
 * Service Operation - UPDATE_GROUP_ENTITY_DATA
 *
 * @param groupId ID of the group.
 * @param entityId ID of the entity.
 * @param version The current version of the group entity (for concurrency checking).
 * @param data Custom application data.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.updateGroupEntityData = function(groupId, entityId, version, data, callback) {
    var message = {
        groupId : groupId,
        entityId : entityId,
        version : version,
        data : data
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_UPDATE_GROUP_ENTITY,
        data : message,
        callback : callback
    });
};

/**
 * Update a member of the group.
 *
 * Service Name - group
 * Service Operation - UPDATE_GROUP_MEMBER
 *
 * @param groupId ID of the group.
 * @param profileId Profile ID of the member being updated.
 * @param role Role of the member being updated (optional).
 * @param attributes Attributes of the member being updated (optional).
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.updateGroupMember = function(groupId, profileId, role, attributes, callback) {
    var message = {
        groupId : groupId,
        profileId : profileId
    };

    if(role) message.role = role;
    if(attributes) message.attributes = attributes;

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_UPDATE_GROUP_MEMBER,
        data : message,
        callback : callback
    });
};

/**
 * Updates a group's name.
 *
 * Service Name - group
 * Service Operation - UPDATE_GROUP_NAME
 *
 * @param groupId ID of the group.
 * @param name Name to apply.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.group.updateGroupName = function(groupId, name, callback) {
    var message = {
        groupId : groupId,
        name : name
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_GROUP,
        operation : brainCloudClient.group.OPERATION_UPDATE_GROUP_NAME,
        data : message,
        callback : callback
    });
};

brainCloudClient.identity = {};

brainCloudClient.SERVICE_IDENTITY = "identity";

brainCloudClient.identity.OPERATION_ATTACH = "ATTACH";
brainCloudClient.identity.OPERATION_MERGE = "MERGE";
brainCloudClient.identity.OPERATION_DETACH = "DETACH";
brainCloudClient.identity.OPERATION_SWITCH_TO_CHILD_PROFILE = "SWITCH_TO_CHILD_PROFILE";
brainCloudClient.identity.OPERATION_SWITCH_TO_PARENT_PROFILE = "SWITCH_TO_PARENT_PROFILE";
brainCloudClient.identity.OPERATION_GET_CHILD_PROFILES = "GET_CHILD_PROFILES";
brainCloudClient.identity.OPERATION_GET_IDENTITIES = "GET_IDENTITIES";
brainCloudClient.identity.OPERATION_GET_EXPIRED_IDENTITIES = "GET_EXPIRED_IDENTITIES";
brainCloudClient.identity.OPERATION_REFRESH_IDENTITY = "REFRESH_IDENTITY";
brainCloudClient.identity.OPERATION_ATTACH_PARENT_WITH_IDENTITY = "ATTACH_PARENT_WITH_IDENTITY";
brainCloudClient.identity.OPERATION_DETACH_PARENT = "DETACH_PARENT";
brainCloudClient.identity.OPERATION_ATTACH_PEER_PROFILE = "ATTACH_PEER_PROFILE";
brainCloudClient.identity.OPERATION_DETACH_PEER = "DETACH_PEER";
brainCloudClient.identity.OPERATION_GET_PEER_PROFILES = "GET_PEER_PROFILES";

brainCloudClient.identity.authenticationType = Object.freeze({
    anonymous : "Anonymous",
    universal : "Universal",
    email : "Email",
    facebook : "Facebook",
    gameCenter : "GameCenter",
    steam : "Steam",
    google : "Google",
    twitter : "Twitter",
    parse : "Parse",
    external : "External",
    unknown : "UNKNOWN"
});

/**
 * Attach the user's Facebook credentials to the current profile.
 *
 * Service Name - Identity
 * Service Operation - Attach
 *
 * @param facebookId The facebook id of the user
 * @param authenticationToken The validated token from the Facebook SDK
 *   (that will be further validated when sent to the bC service)
 * @param callback The method to be invoked when the server response is received
 *
 * Errors to watch for:  SWITCHING_PROFILES - this means that the Facebook identity you provided
 * already points to a different profile.  You will likely want to offer the player the
 * choice to *SWITCH* to that profile, or *MERGE* the profiles.
 *
 * To switch profiles, call ClearSavedProfileID() and call AuthenticateFacebook().
 */
brainCloudClient.identity.attachFacebookIdentity = function(facebookId, authenticationToken, callback) {
    brainCloudClient.identity.attachIdentity(facebookId, authenticationToken, brainCloudClient.authentication.AUTHENTICATION_TYPE_FACEBOOK, callback);
};

/**
 * Merge the profile associated with the provided Facebook credentials with the
 * current profile.
 *
 * Service Name - Identity
 * Service Operation - Merge
 *
 * @param facebookId The facebook id of the user
 * @param authenticationToken The validated token from the Facebook SDK
 *   (that will be further validated when sent to the bC service)
 * @param callback The method to be invoked when the server response is received
 *
 */
brainCloudClient.identity.mergeFacebookIdentity = function(facebookId, authenticationToken, callback) {
    brainCloudClient.identity.mergeIdentity(facebookId, authenticationToken, brainCloudClient.authentication.AUTHENTICATION_TYPE_FACEBOOK, callback);
};

/**
 * Detach the Facebook identity from this profile.
 *
 * Service Name - Identity
 * Service Operation - Detach
 *
 * @param facebookId The Facebook id of the user
 * @param continueAnon Proceed even if the profile will revert to anonymous?
 * @param callback The method to be invoked when the server response is received
 *
 * Watch for DOWNGRADING_TO_ANONYMOUS_ERROR - occurs if you set continueAnon to false, and
 * disconnecting this identity would result in the profile being anonymous (which means that
 * the profile wouldn't be retrievable if the user loses their device)
 */
brainCloudClient.identity.detachFacebookIdentity = function(facebookId, continueAnon, callback) {
    brainCloudClient.identity.detachIdentity(facebookId, brainCloudClient.authentication.AUTHENTICATION_TYPE_FACEBOOK, continueAnon, callback);
};

/**
 * Attach a Game Center identity to the current profile.
 *
 * Service Name - Identity
 * Service Operation - Attach
 *
 * @param gameCenterId The player's game center id  (use the playerID property from the local GKPlayer object)
 * @param callback The method to be invoked when the server response is received
 *
 * Errors to watch for:  SWITCHING_PROFILES - this means that the identity you provided
 * already points to a different profile.  You will likely want to offer the player the
 * choice to *SWITCH* to that profile, or *MERGE* the profiles.
 *
 * To switch profiles, call ClearSavedProfileID() and call this method again.
 *
 */
brainCloudClient.identity.attachGameCenterIdentity = function(gameCenterId, callback) {
    brainCloudClient.identity.detachIdentity(gameCenterId, "", authenticationToken, brainCloudClient.authentication.AUTHENTICATION_TYPE_GAME_CENTER, callback);
};

/**
 * Merge the profile associated with the specified Game Center identity with the current profile.
 *
 * Service Name - Identity
 * Service Operation - Merge
 *
 * @param gameCenterId The player's game center id  (use the playerID property from the local GKPlayer object)
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.mergeGameCenterIdentity = function(gameCenterId, callback) {
    brainCloudClient.identity.detachIdentity(gameCenterId, "", authenticationToken, brainCloudClient.authentication.AUTHENTICATION_TYPE_GAME_CENTER, callback);
};

/**
 * Detach the Game Center identity from the current profile.
 *
 * Service Name - Identity
 * Service Operation - Detach
 *
 * @param gameCenterId The player's game center id  (use the playerID property from the local GKPlayer object)
 * @param continueAnon Proceed even if the profile will revert to anonymous?
 * @param callback The method to be invoked when the server response is received
 *
 * Watch for DOWNGRADING_TO_ANONYMOUS_ERROR - occurs if you set continueAnon to false, and
 * disconnecting this identity would result in the profile being anonymous (which means that
 * the profile wouldn't be retrievable if the user loses their device)
 */
brainCloudClient.identity.detachGameCenterIdentity = function(gameCenterId, continueAnon, callback) {
    brainCloudClient.identity.detachIdentity(gameCenterId, brainCloudClient.authentication.AUTHENTICATION_TYPE_GAME_CENTER, continueAnon, callback);
};

/**
 * Attach a Email and Password identity to the current profile.
 *
 * Service Name - Identity
 * Service Operation - Attach
 *
 * @param email The player's e-mail address
 * @param password The player's password
 * @param callback The method to be invoked when the server response is received
 *
 * Errors to watch for:  SWITCHING_PROFILES - this means that the email address you provided
 * already points to a different profile.  You will likely want to offer the player the
 * choice to *SWITCH* to that profile, or *MERGE* the profiles.
 *
 * To switch profiles, call ClearSavedProfileID() and then call AuthenticateEmailPassword().
 */
brainCloudClient.identity.attachEmailIdentity = function(email, password, callback) {
    brainCloudClient.identity.attachIdentity(email, password, brainCloudClient.authentication.AUTHENTICATION_TYPE_EMAIL, callback);
};

/**
 * Merge the profile associated with the provided e=mail with the current profile.
 *
 * Service Name - Identity
 * Service Operation - Merge
 *
 * @param email The player's e-mail address
 * @param password The player's password
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.mergeEmailIdentity = function(email, password, callback) {
    brainCloudClient.identity.mergeIdentity(email, password, brainCloudClient.authentication.AUTHENTICATION_TYPE_EMAIL, callback);
};

/**
 * Detach the e-mail identity from the current profile
 *
 * Service Name - Identity
 * Service Operation - Detach
 *
 * @param email The player's e-mail address
 * @param continueAnon Proceed even if the profile will revert to anonymous?
 * @param callback The method to be invoked when the server response is received
 *
 * Watch for DOWNGRADING_TO_ANONYMOUS_ERROR - occurs if you set continueAnon to false, and
 * disconnecting this identity would result in the profile being anonymous (which means that
 * the profile wouldn't be retrievable if the user loses their device)
 */
brainCloudClient.identity.detachEmailIdentity = function(email, continueAnon, callback) {
    brainCloudClient.identity.detachIdentity(email, brainCloudClient.authentication.AUTHENTICATION_TYPE_EMAIL, continueAnon, callback);
};

/**
 * Attach a Universal (userId + password) identity to the current profile.
 *
 * Service Name - Identity
 * Service Operation - Attach
 *
 * @param userId The player's userId
 * @param password The player's password
 * @param callback The method to be invoked when the server response is received
 *
 * Errors to watch for:  SWITCHING_PROFILES - this means that the email address you provided
 * already points to a different profile.  You will likely want to offer the player the
 * choice to *SWITCH* to that profile, or *MERGE* the profiles.
 *
 * To switch profiles, call ClearSavedProfileID() and then call AuthenticateEmailPassword().
 */
brainCloudClient.identity.attachUniversalIdentity = function(userId, password, callback) {
    brainCloudClient.identity.attachIdentity(userId, password, brainCloudClient.authentication.AUTHENTICATION_TYPE_UNIVERSAL, callback);
};

/**
 * Merge the profile associated with the provided userId with the current profile.
 *
 * Service Name - Identity
 * Service Operation - Merge
 *
 * @param userId The player's userId
 * @param password The player's password
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.mergeUniversalIdentity = function(userId, password, callback) {
    brainCloudClient.identity.mergeIdentity(userId, password, brainCloudClient.authentication.AUTHENTICATION_TYPE_UNIVERSAL, callback);
};

/**
 * Detach the universal identity from the current profile
 *
 * Service Name - Identity
 * Service Operation - Detach
 *
 * @param userId The player's userId
 * @param continueAnon Proceed even if the profile will revert to anonymous?
 * @param callback The method to be invoked when the server response is received
 *
 * Watch for DOWNGRADING_TO_ANONYMOUS_ERROR - occurs if you set in_continueAnon to false, and
 * disconnecting this identity would result in the profile being anonymous (which means that
 * the profile wouldn't be retrievable if the user loses their device)
 */
brainCloudClient.identity.detachUniversalIdentity = function(userId, continueAnon, callback) {
    brainCloudClient.identity.detachIdentity(userId, brainCloudClient.authentication.AUTHENTICATION_TYPE_UNIVERSAL, continueAnon, callback);
};

/**
 * Attach a Steam (steamId + steamsessionticket) identity to the current profile.
 *
 * Service Name - Identity
 * Service Operation - Attach
 *
 * @param steamId String representation of 64 bit steam id
 * @param sessionTicket The player's session ticket (hex encoded)
 * @param callback The method to be invoked when the server response is received
 *
 * Errors to watch for:  SWITCHING_PROFILES - this means that the email address you provided
 * already points to a different profile.  You will likely want to offer the player the
 * choice to *SWITCH* to that profile, or *MERGE* the profiles.
 *
 * To switch profiles, call ClearSavedProfileID() and then call AuthenticateSteam().
 */
brainCloudClient.identity.attachSteamIdentity = function(steamId, sessionTicket, callback) {
    brainCloudClient.identity.attachIdentity(steamId, sessionTicket, brainCloudClient.authentication.AUTHENTICATION_TYPE_STEAM, callback);
};

/**
 * Merge the profile associated with the provided steam steamId with the current profile.
 *
 * Service Name - Identity
 * Service Operation - Merge
 *
 * @param steamId String representation of 64 bit steam id
 * @param sessionticket The player's session ticket (hex encoded)
 * @param callback The method to be invoked when the server response is received
 *
 */
brainCloudClient.identity.mergeSteamIdentity = function(steamId, sessionTicket, callback) {
    brainCloudClient.identity.mergeIdentity(steamId, sessionTicket, brainCloudClient.authentication.AUTHENTICATION_TYPE_STEAM, callback);
};

/**
 * Detach the steam identity from the current profile
 *
 * Service Name - Identity
 * Service Operation - Detach
 *
 * @param steamId String representation of 64 bit steam id
 * @param continueAnon Proceed even if the profile will revert to anonymous?
 * @param callback The method to be invoked when the server response is received
 *
 * Watch for DOWNGRADING_TO_ANONYMOUS_ERROR - occurs if you set in_continueAnon to false, and
 * disconnecting this identity would result in the profile being anonymous (which means that
 * the profile wouldn't be retrievable if the user loses their device)
 */
brainCloudClient.identity.detachSteamIdentity = function(steamId, continueAnon, callback) {
    brainCloudClient.identity.detachIdentity(steamId, brainCloudClient.authentication.AUTHENTICATION_TYPE_STEAM, continueAnon, callback);
};

/**
 * Attach the user's Google credentials to the current profile.
 *
 * Service Name - Identity
 * Service Operation - Attach
 *
 * @param googleId The Google id of the user
 * @param authenticationToken The validated token from the Google SDK
 *   (that will be further validated when sent to the bC service)
 * @param callback The method to be invoked when the server response is received
 *
 * Errors to watch for:  SWITCHING_PROFILES - this means that the Google identity you provided
 * already points to a different profile.  You will likely want to offer the player the
 * choice to *SWITCH* to that profile, or *MERGE* the profiles.
 *
 * To switch profiles, call ClearSavedProfileID() and call AuthenticateGoogle().
 */
brainCloudClient.identity.attachGoogleIdentity = function(googleId, authenticationToken, callback) {
    brainCloudClient.identity.attachIdentity(googleId, authenticationToken, brainCloudClient.authentication.AUTHENTICATION_TYPE_GOOGLE, callback);
};

/**
 * Merge the profile associated with the provided Google credentials with the
 * current profile.
 *
 * Service Name - Identity
 * Service Operation - Merge
 *
 * @param googleId The Google id of the user
 * @param authenticationToken The validated token from the Google SDK
 *   (that will be further validated when sent to the bC service)
 * @param callback The method to be invoked when the server response is received
 *
 */
brainCloudClient.identity.mergeGoogleIdentity = function(googleId, authenticationToken, callback) {
    brainCloudClient.identity.mergeIdentity(googleId, authenticationToken, brainCloudClient.authentication.AUTHENTICATION_TYPE_GOOGLE, callback);
};

/**
 * Detach the Google identity from this profile.
 *
 * Service Name - Identity
 * Service Operation - Detach
 *
 * @param googleId The Google id of the user
 * @param continueAnon Proceed even if the profile will revert to anonymous?
 * @param callback The method to be invoked when the server response is received
 *
 * Watch for DOWNGRADING_TO_ANONYMOUS_ERROR - occurs if you set continueAnon to false, and
 * disconnecting this identity would result in the profile being anonymous (which means that
 * the profile wouldn't be retrievable if the user loses their device)
 */
brainCloudClient.identity.detachGoogleIdentity = function(googleId, continueAnon, callback) {
    brainCloudClient.identity.detachIdentity(googleId, brainCloudClient.authentication.AUTHENTICATION_TYPE_GOOGLE, continueAnon, callback);
};

/**
 * Attach the user's Twitter credentials to the current profile.
 *
 * Service Name - Identity
 * Service Operation - Attach
 *
 * @param twitterId The Twitter id of the user
 * @param authenticationToken The validated token from the Twitter SDK
 *   (that will be further validated when sent to the bC service)
 * @param secret The secret given when attempting to link with Twitter
 * @param callback The method to be invoked when the server response is received
 *
 * Errors to watch for:  SWITCHING_PROFILES - this means that the Twitter identity you provided
 * already points to a different profile.  You will likely want to offer the player the
 * choice to *SWITCH* to that profile, or *MERGE* the profiles.
 *
 * To switch profiles, call ClearSavedProfileID() and call AuthenticateTwitter().
 */
brainCloudClient.identity.attachTwitterIdentity = function(twitterId, authenticationToken, secret, callback) {
    brainCloudClient.identity.attachIdentity(twitterId, authenticationToken+":"+secret, brainCloudClient.authentication.AUTHENTICATION_TYPE_TWITTER, callback);
};

/**
 * Merge the profile associated with the provided Twitter credentials with the
 * current profile.
 *
 * Service Name - Identity
 * Service Operation - Merge
 *
 * @param twitterId The Twitter id of the user
 * @param authenticationToken The validated token from the Twitter SDK
 *   (that will be further validated when sent to the bC service)
 * @param secret The secret given when attempting to link with Twitter
 * @param callback The method to be invoked when the server response is received
 *
 */
brainCloudClient.identity.mergeTwitterIdentity = function(twitterId, authenticationToken, secret, callback) {
    brainCloudClient.identity.mergeIdentity(twitterId, authenticationToken+":"+secret, brainCloudClient.authentication.AUTHENTICATION_TYPE_TWITTER, callback);
};

/**
 * Detach the Twitter identity from this profile.
 *
 * Service Name - Identity
 * Service Operation - Detach
 *
 * @param twitterId The Twitter id of the user
 * @param continueAnon Proceed even if the profile will revert to anonymous?
 * @param callback The method to be invoked when the server response is received
 *
 * Watch for DOWNGRADING_TO_ANONYMOUS_ERROR - occurs if you set continueAnon to false, and
 * disconnecting this identity would result in the profile being anonymous (which means that
 * the profile wouldn't be retrievable if the user loses their device)
 */
brainCloudClient.identity.detachTwitterIdentity = function(twitterId, continueAnon, callback) {
    brainCloudClient.identity.detachIdentity(twitterId, brainCloudClient.authentication.AUTHENTICATION_TYPE_TWITTER, continueAnon, callback);
};

/**
 * Attach the user's Parse credentials to the current profile.
 *
 * Service Name - Identity
 * Service Operation - Attach
 *
 * @param parseId The parse id of the user
 * @param authenticationToken The validated token from Parse
 *   (that will be further validated when sent to the bC service)
 * @param callback The method to be invoked when the server response is received
 *
 * Errors to watch for:  SWITCHING_PROFILES - this means that the Parse identity you provided
 * already points to a different profile.  You will likely want to offer the player the
 * choice to *SWITCH* to that profile, or *MERGE* the profiles.
 *
 * To switch profiles, call ClearSavedProfileID() and call AuthenticateParse().
 */
brainCloudClient.identity.attachParseIdentity = function(parseId, authenticationToken, callback) {
    brainCloudClient.identity.attachIdentity(parseId, authenticationToken, brainCloudClient.authentication.AUTHENTICATION_TYPE_PARSE, callback);
};

/**
 * Merge the profile associated with the provided Parse credentials with the
 * current profile.
 *
 * Service Name - Identity
 * Service Operation - Merge
 *
 * @param parseId The Parse id of the user
 * @param authenticationToken The validated token from Parse
 *   (that will be further validated when sent to the bC service)
 * @param callback The method to be invoked when the server response is received
 *
 */
brainCloudClient.identity.mergeParseIdentity = function(parseId, authenticationToken, callback) {
    brainCloudClient.identity.mergeIdentity(parseId, authenticationToken, brainCloudClient.authentication.AUTHENTICATION_TYPE_PARSE, callback);
};

/**
 * Detach the Parse identity from this profile.
 *
 * Service Name - Identity
 * Service Operation - Detach
 *
 * @param parseId The Parse id of the user
 * @param continueAnon Proceed even if the profile will revert to anonymous?
 * @param callback The method to be invoked when the server response is received
 *
 * Watch for DOWNGRADING_TO_ANONYMOUS_ERROR - occurs if you set continueAnon to false, and
 * disconnecting this identity would result in the profile being anonymous (which means that
 * the profile wouldn't be retrievable if the user loses their device)
 */
brainCloudClient.identity.detachParseIdentity = function(parseId, continueAnon, callback) {
    brainCloudClient.identity.detachIdentity(parseId, brainCloudClient.authentication.AUTHENTICATION_TYPE_PARSE, continueAnon, callback);
};


/**
 * Switch to a Child Profile
 *
 * Service Name - Identity
 * Service Operation - SWITCH_TO_CHILD_PROFILE
 *
 * @param childProfileId The profileId of the child profile to switch to
 * If null and forceCreate is true a new profile will be created
 * @param childAppId The appId of the child app to switch to
 * @param forceCreate Should a new profile be created if it does not exist?
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.switchToChildProfile = function(childProfileId, childAppId, forceCreate, callback) {

    brainCloudClient.identity.switchToChildProfileInternal(childProfileId, childAppId, forceCreate, false, callback);
};

/**
 * Switches to a child profile of an app when only one profile exists
 * If multiple profiles exist this returns an error
 *
 * Service Name - Identity
 * Service Operation - SWITCH_TO_CHILD_PROFILE
 *
 * @param childAppId The App ID of the child app to switch to
 * @param forceCreate Should a new profile be created if it does not exist?
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.switchToSingletonChildProfile = function(childAppId, forceCreate, callback) {

    brainCloudClient.identity.switchToChildProfileInternal(null, childAppId, forceCreate, true, callback);
};

/**
 * Switch to a Parent Profile
 *
 * Service Name - Identity
 * Service Operation - SWITCH_TO_PARENT_PROFILE
 *
 * @param parentLevelName The level of the parent to switch to
 * If null and forceCreate is true a new profile will be created
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.switchToParentProfile = function(parentLevelName, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_SWITCH_TO_PARENT_PROFILE,
        data: {
            levelName : parentLevelName
        },
        callback: callback
    });
};

/**
 * Returns a list of all child profiles in child Apps
 *
 * Service Name - Identity
 * Service Operation - GET_CHILD_PROFILES
 *
 * @param includeSummaryData Whether to return the summary friend data along with this call
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.getChildProfiles = function(includeSummaryData, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_GET_CHILD_PROFILES,
        data: {
            includePlayerSummaryData : includeSummaryData
        },
        callback: callback
    });
};

/**
 * Retrieve list of identities
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.getIdentities = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_GET_IDENTITIES,
        data: {},
        callback: callback
    });
};

/**
 * Retrieve list of expired identities
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.getExpiredIdentities = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_GET_EXPIRED_IDENTITIES,
        data: {},
        callback: callback
    });
};

/**
 * Refreshes an identity for this player
 *
 * Service Name - identity
 * Service Operation - REFRESH_IDENTITY
 *
 * @param externalId User ID
 * @param authenticationToken Password or client side token
 * @param authenticationType Type of authentication
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.refreshIdentity = function(externalId, authenticationToken, authenticationType, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_REFRESH_IDENTITY,
        data: {
            externalId : externalId,
            authenticationType : authenticationType,
            authenticationToken : authenticationToken
        },
        callback: callback
    });
}

/**
 * Attach a new identity to a parent app
 *
 * Service Name - identity
 * Service Operation - ATTACH_PARENT_WITH_IDENTITY
 *
 * @param externalId The users id for the new credentials
 * @param authenticationToken The password/token
 * @param authenticationType Type of identity
 * @param externalAuthName Optional - if attaching an external identity
 * @param forceCreate Should a new profile be created if it does not exist?
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.attachParentWithIdentity = function(externalId, authenticationToken, authenticationType, externalAuthName, forceCreate, callback) {
    var data = {
        externalId : externalId,
        authenticationToken : authenticationToken,
        authenticationType : authenticationType,
        forceCreate : forceCreate
    };

    if(externalAuthName)
        data.externalAuthName = externalAuthName;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_ATTACH_PARENT_WITH_IDENTITY,
        data: data,
        callback: callback
    });
}

/**
 * Detaches parent from this player's profile
 *
 * Service Name - identity
 * Service Operation - DETACH_PARENT
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.detachParent = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_DETACH_PARENT,
        data: null,
        callback: callback
    });
}

/**
 * Attaches a peer identity to this player's profile
 *
 * Service Name - identity
 * Service Operation - ATTACH_PEER_PROFILE
 *
 * @param peer Name of the peer to connect to
 * @param externalId The users id for the new credentials
 * @param authenticationToken The password/token
 * @param authenticationType Type of identity
 * @param externalAuthName Optional - if attaching an external identity
 * @param forceCreate Should a new profile be created if it does not exist?
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.attachPeerProfile = function(peer, externalId, authenticationToken, authenticationType, externalAuthName, forceCreate, callback) {
    var data = {
        peer: peer,
        externalId : externalId,
        authenticationToken : authenticationToken,
        authenticationType : authenticationType,
        forceCreate : forceCreate
    };

    if(externalAuthName)
        data.externalAuthName = externalAuthName;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_ATTACH_PEER_PROFILE,
        data: data,
        callback: callback
    });
}

/**
 * Detaches a peer identity from this player's profile
 *
 * Service Name - identity
 * Service Operation - DETACH_PEER
 *
 * @param peer Name of the peer to connect to
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.detachPeer = function(peer, callback) {
    var data = {
        peer: peer
    };

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_DETACH_PEER,
        data: data,
        callback: callback
    });
}

/**
 * Returns a list of peer profiles attached to this user
 *
 * Service Name - identity
 * Service Operation - GET_PEER_PROFILES
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.identity.getPeerProfiles = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_GET_PEER_PROFILES,
        data: null,
        callback: callback
    });
}


//internal methods

brainCloudClient.identity.attachIdentity = function(externalId, authenticationToken, authenticationType, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_ATTACH,
        data: {
            externalId : externalId,
            authenticationType : authenticationType,
            authenticationToken : authenticationToken
        },
        callback: callback
    });
};

brainCloudClient.identity.mergeIdentity = function(externalId, authenticationToken, authenticationType, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_MERGE,
        data: {
            externalId : externalId,
            authenticationType : authenticationType,
            authenticationToken : authenticationToken
        },
        callback: callback
    });
};

brainCloudClient.identity.detachIdentity = function(externalId, authenticationType, continueAnon, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_DETACH,
        data: {
            externalId : externalId,
            authenticationType : authenticationType,
            confirmAnonymous : continueAnon
        },
        callback: callback
    });
};

brainCloudClient.identity.switchToChildProfileInternal = function(childProfileId, childAppId, forceCreate, forceSingleton, callback) {

    var _navLangCode = window.navigator.userLanguage || window.navigator.language;
    _navLangCode = _navLangCode.split("-");
    var languageCode = _navLangCode[0];
    var countryCode = _navLangCode[1];

    var now = new Date();
    var timeZoneOffset = -now.getTimezoneOffset() / 60.0;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_IDENTITY,
        operation: brainCloudClient.identity.OPERATION_SWITCH_TO_CHILD_PROFILE,
        data: {
            profileId : childProfileId,
            gameId : childAppId,
            forceCreate : forceCreate,
            forceSingleton : forceSingleton,
            releasePlatform: "WEB",
            timeZoneOffset : timeZoneOffset,
            languageCode : languageCode,
            countryCode : countryCode
        },
        callback: callback
    });
};

brainCloudClient.mail = {};

brainCloudClient.SERVICE_MAIL = "mail";

brainCloudClient.mail.OPERATION_SEND_BASIC_EMAIL = "SEND_BASIC_EMAIL";
brainCloudClient.mail.OPERATION_SEND_ADVANCED_EMAIL = "SEND_ADVANCED_EMAIL";
brainCloudClient.mail.OPERATION_SEND_ADVANCED_EMAIL_BY_ADDRESS = "SEND_ADVANCED_EMAIL_BY_ADDRESS";

/**
 * Sends a simple text email to the specified player
 *
 * Service Name - mail
 * Service Operation - SEND_BASIC_EMAIL
 *
 * @param profileId The user to send the email to
 * @param subject The email subject
 * @param body The email body
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.mail.sendBasicEmail = function(profileId, subject, body, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MAIL,
        operation: brainCloudClient.mail.OPERATION_SEND_BASIC_EMAIL,
        data: {
            profileId: profileId,
            subject: subject,
            body: body
        },
        callback: callback
    });
};

/**
 * Sends an advanced email to the specified player
 *
 * Service Name - mail
 * Service Operation - SEND_ADVANCED_EMAIL
 *
 * @param profileId The user to send the email to
 * @param serviceParams Parameters to send to the email service. See the documentation for
 *	a full list. http://getbraincloud.com/apidocs/apiref/#capi-mail
 * @param in_callback The method to be invoked when the server response is received
 */
brainCloudClient.mail.sendAdvancedEmail = function(profileId, serviceParams, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MAIL,
        operation: brainCloudClient.mail.OPERATION_SEND_ADVANCED_EMAIL,
        data: {
            profileId: profileId,
            serviceParams: serviceParams
        },
        callback: callback
    });
};

/**
 * Sends an advanced email to the specified email address
 *
 * Service Name - mail
 * Service Operation - SEND_ADVANCED_EMAIL_BY_ADDRESS
 *
 * @param emailAddress The address to send the email to
 * @param serviceParams Parameters to send to the email service. See the documentation for
 *	a full list. http://getbraincloud.com/apidocs/apiref/#capi-mail
 * @param in_callback The method to be invoked when the server response is received
 */
brainCloudClient.mail.sendAdvancedEmailByAddress = function(emailAddress, serviceParams, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MAIL,
        operation: brainCloudClient.mail.OPERATION_SEND_ADVANCED_EMAIL_BY_ADDRESS,
        data: {
            emailAddress: emailAddress,
            serviceParams: serviceParams
        },
        callback: callback
    });
};
brainCloudClient.matchMaking = {};

brainCloudClient.SERVICE_MATCH_MAKING = "matchMaking";

brainCloudClient.matchMaking.OPERATION_READ                             = "READ";
brainCloudClient.matchMaking.OPERATION_SET_PLAYER_RATING                = "SET_PLAYER_RATING";
brainCloudClient.matchMaking.OPERATION_RESET_PLAYER_RATING              = "RESET_PLAYER_RATING";
brainCloudClient.matchMaking.OPERATION_INCREMENT_PLAYER_RATING          = "INCREMENT_PLAYER_RATING";
brainCloudClient.matchMaking.OPERATION_DECREMENT_PLAYER_RATING          = "DECREMENT_PLAYER_RATING";
brainCloudClient.matchMaking.OPERATION_TURN_SHIELD_ON                   = "SHIELD_ON";
brainCloudClient.matchMaking.OPERATION_TURN_SHIELD_ON_FOR               = "SHIELD_ON_FOR";
brainCloudClient.matchMaking.OPERATION_TURN_SHIELD_OFF                  = "SHIELD_OFF";
brainCloudClient.matchMaking.OPERATION_GET_SHIELD_EXPIRY                = "GET_SHIELD_EXPIRY";
brainCloudClient.matchMaking.OPERATION_FIND_PLAYERS                     = "FIND_PLAYERS";
brainCloudClient.matchMaking.OPERATION_FIND_PLAYERS_USING_FILTER        = "FIND_PLAYERS_USING_FILTER";
brainCloudClient.matchMaking.OPERATION_ENABLE_MATCH_MAKING              = "ENABLE_FOR_MATCH";
brainCloudClient.matchMaking.OPERATION_DISABLE_MATCH_MAKING             = "DISABLE_FOR_MATCH";


/**
 * Read match making record
 *
 * Service Name - MatchMaking
 * Service Operation - Read
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.matchMaking.read = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_READ,
        data: {},
        callback: callback
    });
};

/**
 * Sets player rating
 *
 * Service Name - MatchMaking
 * Service Operation - SetPlayerRating
 *
 * @param playerRating The new player rating.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.matchMaking.setPlayerRating = function(playerRating, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_SET_PLAYER_RATING,
        data: {
            playerRating: playerRating
        },
        callback: callback
    });
};

/**
* Resets player rating
*
* Service Name - MatchMaking
* Service Operation - ResetPlayerRating
*
* @param callback The callback function
*/
brainCloudClient.matchMaking.resetPlayerRating = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_RESET_PLAYER_RATING,
        data: {},
        callback: callback
    });
};

/**
* Increments player rating
*
* Service Name - MatchMaking
* Service Operation - IncrementPlayerRating
*
* @param increment The increment amount
* @param callback The callback function
*/
brainCloudClient.matchMaking.incrementPlayerRating = function(increment, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_INCREMENT_PLAYER_RATING,
        data: {
            playerRating: increment
        },
        callback: callback
    });
};

/**
* Decrements player rating
*
* Service Name - MatchMaking
* Service Operation - DecrementPlayerRating
*
* @param decrement The decrement amount
* @param callback The callback function
*/
brainCloudClient.matchMaking.decrementPlayerRating = function(decrement, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_DECREMENT_PLAYER_RATING,
        data: {
            playerRating: decrement
        },
        callback: callback
    });
};


/**
* Turns shield on
*
* Service Name - MatchMaking
* Service Operation - ShieldOn
*
* @param callback The callback function
*/
brainCloudClient.matchMaking.turnShieldOn = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_TURN_SHIELD_ON,
        data: {},
        callback: callback
    });
};


/**
* Turns shield on for the specified number of minutes
*
* Service Name - MatchMaking
* Service Operation - ShieldOnFor
*
* @param minutes Number of minutes to turn the shield on for
* @param callback The callback function
*/
brainCloudClient.matchMaking.turnShieldOnFor = function(minutes, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_TURN_SHIELD_ON_FOR,
        data: {
            minutes: minutes
        },
        callback: callback
    });
};


/**
* Turns shield off
*
* Service Name - MatchMaking
* Service Operation - ShieldOff
*
* @param callback The callback function
*/
brainCloudClient.matchMaking.turnShieldOff = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_TURN_SHIELD_OFF,
        data: {},
        callback: callback
    });
};


/**
 * Gets the shield expiry for the given player id. Passing in a null player id
 * will return the shield expiry for the current player. The value returned is
 * the time in UTC millis when the shield will expire.
 *
 * Service Name - MatchMaking
 * Service Operation - GetShieldExpiry
 *
 * @param playerId The player id or use null to retrieve for the current player
 * @param callback The callback.
 */
brainCloudClient.matchMaking.getShieldExpiry = function(playerId, callback) {
    var data = {};
    if (playerId)
    {
        data["playerId"] = playerId;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_GET_SHIELD_EXPIRY,
        data: data,
        callback: callback
    });
};


/**
* Finds matchmaking enabled players
*
* Service Name - MatchMaking
* Service Operation - FIND_PLAYERS
*
* @param rangeDelta The range delta
* @param numMatches The maximum number of matches to return
* @param callback The callback.
*/
brainCloudClient.matchMaking.findPlayers = function(rangeDelta, numMatches, callback) {
    brainCloudClient.matchMaking.findPlayersWithAttributes(rangeDelta, numMatches, null, callback);
};

/**
 * Finds matchmaking enabled players with additional attributes
 *
 * Service Name - MatchMaking
 * Service Operation - FIND_PLAYERS
 *
 * @param rangeDelta The range delta
 * @param numMatches The maximum number of matches to return
 * @param jsonAttributes Attributes match criteria
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.matchMaking.findPlayersWithAttributes = function(rangeDelta, numMatches, jsonAttributes, callback) {
    var data = {
        rangeDelta: rangeDelta,
        numMatches: numMatches
    };

    if (jsonAttributes) {
        data.attributes = jsonAttributes;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_FIND_PLAYERS,
        data: data,
        callback: callback
    });
};

/**
* @deprecated Use findPlayersUsingFilter instead - Removal after June 21 2016
*/
brainCloudClient.matchMaking.findPlayersWithFilter = function(rangeDelta, numMatches, extraParms, callback) {
    brainCloudClient.matchMaking.findPlayersUsingFilter(rangeDelta, numMatches, extraParms, callback);
};

/**
* Finds matchmaking enabled players
*
* Service Name - MatchMaking
* Service Operation - FIND_PLAYERS_WITH_FILTER
*
* @param rangeDelta The range delta
* @param numMatches The maximum number of matches to return
* @param extraParms Other parameters
* @param callback The callback.
*/
brainCloudClient.matchMaking.findPlayersUsingFilter = function(rangeDelta, numMatches, extraParms, callback) {
    brainCloudClient.matchMaking.findPlayersWithAttributesUsingFilter(rangeDelta, numMatches, null, extraParms, callback);
};

/**
* Finds matchmaking enabled players using a cloud code filter
* and additional attributes
*
* Service Name - MatchMaking
* Service Operation - FIND_PLAYERS_USING_FILTER
*
* @param rangeDelta The range delta
* @param numMatches The maximum number of matches to return
* @param jsonAttributes Attributes match criteria
* @param jsonExtraParms Parameters to pass to the CloudCode filter script
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.matchMaking.findPlayersWithAttributesUsingFilter = function(rangeDelta, numMatches, jsonAttributes, extraParms, callback) {
    var data = {
        rangeDelta: rangeDelta,
        numMatches: numMatches
    };
    if (jsonAttributes) {
        data.attributes = jsonAttributes;
    }
    if (extraParms) {
        data.extraParms = extraParms;
    }
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_FIND_PLAYERS_USING_FILTER,
        data: data,
        callback: callback
    });
};

/**
 * Enables Match Making for the Player
 *
 * Service Name - MatchMaking
 * Service Operation - EnableMatchMaking
 *
 * @param callback The callback.
 */
brainCloudClient.matchMaking.enableMatchMaking = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_ENABLE_MATCH_MAKING,
        data: {},
        callback: callback
    });
};

/**
 * Disables Match Making for the Player
 *
 * Service Name - MatchMaking
 * Service Operation - EnableMatchMaking
 *
 * @param callback The callback.
 */
brainCloudClient.matchMaking.disableMatchMaking = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_MATCH_MAKING,
        operation: brainCloudClient.matchMaking.OPERATION_DISABLE_MATCH_MAKING,
        data: {},
        callback: callback
    });
};

brainCloudClient.oneWayMatch = {};

brainCloudClient.SERVICE_ONE_WAY_MATCH = "onewayMatch";

brainCloudClient.oneWayMatch.OPERATION_START_MATCH = "START_MATCH";
brainCloudClient.oneWayMatch.OPERATION_CANCEL_MATCH = "CANCEL_MATCH";
brainCloudClient.oneWayMatch.OPERATION_COMPLETE_MATCH = "COMPLETE_MATCH";


/**
 * Starts a match
 *
 * Service Name - OneWayMatch
 * Service Operation - StartMatch
 *
 * @param otherPlayerId The player to start a match with
 * @param rangeDelta The range delta used for the initial match search
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.oneWayMatch.startMatch = function(otherPlayerId, rangeDelta, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ONE_WAY_MATCH,
        operation: brainCloudClient.oneWayMatch.OPERATION_START_MATCH,
        data: {
            playerId : otherPlayerId,
            rangeDelta : rangeDelta             
        },
        callback: callback
    });
};


/**
 * Cancels a match
 *
 * Service Name - OneWayMatch
 * Service Operation - CancelMatch
 *
 * @param playbackStreamId The playback stream id returned in the start match
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.oneWayMatch.cancelMatch = function(playbackStreamId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ONE_WAY_MATCH,
        operation: brainCloudClient.oneWayMatch.OPERATION_CANCEL_MATCH,
        data: {
            playbackStreamId : playbackStreamId
        },
        callback: callback
    });
};


/**
 * Completes a match
 *
 * Service Name - OneWayMatch
 * Service Operation - CompleteMatch
 *
 * @param playbackStreamId The playback stream id returned in the initial start match
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.oneWayMatch.completeMatch = function(playbackStreamId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_ONE_WAY_MATCH,
        operation: brainCloudClient.oneWayMatch.OPERATION_COMPLETE_MATCH,
        data: {
            playbackStreamId : playbackStreamId
        },
        callback: callback
    });
};
brainCloudClient.playbackStream = {};

brainCloudClient.SERVICE_PLAYBACK_STREAM = "playbackStream";

brainCloudClient.playbackStream.OPERATION_START_STREAM = "START_STREAM";
brainCloudClient.playbackStream.OPERATION_READ_STREAM = "READ_STREAM";
brainCloudClient.playbackStream.OPERATION_END_STREAM = "END_STREAM";
brainCloudClient.playbackStream.OPERATION_DELETE_STREAM = "DELETE_STREAM";
brainCloudClient.playbackStream.OPERATION_ADD_EVENT = "ADD_EVENT";
brainCloudClient.playbackStream.OPERATION_GET_STREAM_SUMMARIES_FOR_INITIATING_PLAYER = "GET_STREAM_SUMMARIES_FOR_INITIATING_PLAYER";
brainCloudClient.playbackStream.OPERATION_GET_STREAM_SUMMARIES_FOR_TARGET_PLAYER = "GET_STREAM_SUMMARIES_FOR_TARGET_PLAYER";
brainCloudClient.playbackStream.OPERATION_GET_RECENT_STREAMS_FOR_INITIATING_PLAYER = "GET_RECENT_STREAMS_FOR_INITIATING_PLAYER";
brainCloudClient.playbackStream.OPERATION_GET_RECENT_STREAMS_FOR_TARGET_PLAYER = "GET_RECENT_STREAMS_FOR_TARGET_PLAYER";

/**
 * Method starts a new playback stream.
 * 
 * @param targetPlayerId
 *            {string} The player to start a stream with
 * @param includeSharedData
 *            {boolean} Whether to include shared data in the stream
 * @param callback
 *            {function} The callback handler.
 */
brainCloudClient.playbackStream.startStream = function(targetPlayerId, includeSharedData, callback) {
    var message = {
        targetPlayerId : targetPlayerId,
        includeSharedData : includeSharedData
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYBACK_STREAM,
        operation : brainCloudClient.playbackStream.OPERATION_START_STREAM,
        data : message,
        callback : callback
    });
};

/**
 * Method reads an existing playback stream.
 * 
 * @param playbackStreamId
 *            {string} Identifies the stream
 * @param callback
 *            {function} The callback handler.
 */
brainCloudClient.playbackStream.readStream = function(playbackStreamId, callback) {
    var message = {
            playbackStreamId : playbackStreamId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYBACK_STREAM,
        operation : brainCloudClient.playbackStream.OPERATION_READ_STREAM,
        data : message,
        callback : callback
    });
};

/**
 * Method ends an existing playback stream.
 * 
 * @param playbackStreamId
 *            {string} Identifies the stream
 * @param callback
 *            {function} The callback handler.
 */
brainCloudClient.playbackStream.endStream = function(playbackStreamId, callback) {
    var message = {
            playbackStreamId : playbackStreamId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYBACK_STREAM,
        operation : brainCloudClient.playbackStream.OPERATION_END_STREAM,
        data : message,
        callback : callback
    });
};

/**
 * Method deletes an existing playback stream.
 * 
 * @param playbackStreamId
 *            {string} Identifies the stream
 * @param callback
 *            {function} The callback handler.
 */
brainCloudClient.playbackStream.deleteStream = function(playbackStreamId, callback) {
    var message = {
            playbackStreamId : playbackStreamId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYBACK_STREAM,
        operation : brainCloudClient.playbackStream.OPERATION_DELETE_STREAM,
        data : message,
        callback : callback
    });
};

/**
 * Method adds an event to an existing playback stream.
 * 
 * @param playbackStreamId
 *            {string} Identifies the stream
 * @param eventData
 *            {json} Describes the event
 * @param summary
 *            {json} Summary data
 * @param callback
 *            {function} The callback handler.
 */
brainCloudClient.playbackStream.addEvent = function(playbackStreamId, eventData, summary, callback) {
    var message = {
            playbackStreamId : playbackStreamId,
            eventData : eventData,
            summary : summary
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYBACK_STREAM,
        operation : brainCloudClient.playbackStream.OPERATION_ADD_EVENT,
        data : message,
        callback : callback
    });
};

/**
 * @deprecated Use getRecentStreamsForInitiatingPlayer instead - Removal after September 1 2017
 */
brainCloudClient.playbackStream.getStreamSummariesForInitiatingPlayer = function(initiatingPlayerId, callback) {
    var message = {
            initiatingPlayerId : initiatingPlayerId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYBACK_STREAM,
        operation : brainCloudClient.playbackStream.OPERATION_GET_STREAM_SUMMARIES_FOR_INITIATING_PLAYER,
        data : message,
        callback : callback
    });
};

/**
 * @deprecated Use getRecentStreamsForTargetPlayer instead - Removal after September 1 2017
 */
brainCloudClient.playbackStream.getStreamSummariesForTargetPlayer = function(targetPlayerId, callback) {
    var message = {
            targetPlayerId : targetPlayerId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYBACK_STREAM,
        operation : brainCloudClient.playbackStream.OPERATION_GET_STREAM_SUMMARIES_FOR_TARGET_PLAYER,
        data : message,
        callback : callback
    });
};

/**
 * Method get recent stream summaries for initiating player
 *
 * @param initiatingPlayerId
 *            {string} The player that started the stream
 * @param maxNumStreams
 *            {int} The max number of streams to query
 * @param callback
 *            {function} The callback handler.
 */
brainCloudClient.playbackStream.getRecentStreamsForInitiatingPlayer = function(initiatingPlayerId, maxNumStreams, callback) {
    var message = {
        initiatingPlayerId : initiatingPlayerId,
        maxNumStreams : maxNumStreams
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYBACK_STREAM,
        operation : brainCloudClient.playbackStream.OPERATION_GET_RECENT_STREAMS_FOR_INITIATING_PLAYER,
        data : message,
        callback : callback
    });
};

/**
 * Method gets recent stream summaries for target player
 *
 * @param targetPlayerId
 *            {string} The player that was the target of the stream
 * @param maxNumStreams
 *            {int} The max number of streams to query
 * @param callback
 *            {function} The callback handler.
 */
brainCloudClient.playbackStream.getRecentStreamsForTargetPlayer = function(targetPlayerId, maxNumStreams, callback) {
    var message = {
        targetPlayerId : targetPlayerId,
        maxNumStreams : maxNumStreams
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYBACK_STREAM,
        operation : brainCloudClient.playbackStream.OPERATION_GET_RECENT_STREAMS_FOR_TARGET_PLAYER,
        data : message,
        callback : callback
    });
};

brainCloudClient.playerState = {};

brainCloudClient.SERVICE_PLAYERSTATE = "playerState";

brainCloudClient.playerState.OPERATION_SEND = "SEND";
brainCloudClient.playerState.OPERATION_UPDATE_EVENT_DATA = "UPDATE_EVENT_DATA";
brainCloudClient.playerState.OPERATION_DELETE_INCOMING = "DELETE_INCOMING";
brainCloudClient.playerState.OPERATION_DELETE_SENT = "DELETE_SENT";
brainCloudClient.playerState.OPERATION_FULL_PLAYER_RESET = "FULL_PLAYER_RESET";
brainCloudClient.playerState.OPERATION_GAME_DATA_RESET = "GAME_DATA_RESET";
brainCloudClient.playerState.OPERATION_UPDATE_SUMMARY = "UPDATE_SUMMARY";
brainCloudClient.playerState.OPERATION_READ_FRIENDS = "READ_FRIENDS";
brainCloudClient.playerState.OPERATION_READ_FRIEND_PLAYER_STATE = "READ_FRIEND_PLAYER_STATE";

brainCloudClient.playerState.UPDATE_ATTRIBUTES = "UPDATE_ATTRIBUTES";
brainCloudClient.playerState.REMOVE_ATTRIBUTES = "REMOVE_ATTRIBUTES";
brainCloudClient.playerState.GET_ATTRIBUTES = "GET_ATTRIBUTES";

brainCloudClient.playerState.UPDATE_PICTURE_URL = "UPDATE_PICTURE_URL";
brainCloudClient.playerState.UPDATE_CONTACT_EMAIL = "UPDATE_CONTACT_EMAIL";

brainCloudClient.playerState.OPERATION_READ = "READ";

brainCloudClient.playerState.OPERATION_UPDATE_NAME = "UPDATE_NAME";
brainCloudClient.playerState.OPERATION_LOGOUT = "LOGOUT";

/**
 * @deprecated Use userPlayer instead - Removal after September 1 2017
 */
brainCloudClient.playerState.deletePlayer = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.OPERATION_FULL_PLAYER_RESET,
        callback : callback
    });
};

/**
 * Completely deletes the user record and all data fully owned
 * by the user. After calling this method, the player will need
 * to re-authenticate and create a new profile.
 * This is mostly used for debugging/qa.
 *
 * Service Name - PlayerState
 * Service Operation - FullReset
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerState.userPlayer = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.OPERATION_FULL_PLAYER_RESET,
        callback : callback
    });
};

/**
* Retrieve the user's attributes.
*
* Service Name - PlayerState
* Service Operation - GetAttributes
*
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.playerState.getAttributes = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.GET_ATTRIBUTES,
        callback : callback
    });
};


/**
 * Logs user out of the server.
 *
 * Service Name - PlayerState
 * Service Operation - Logout
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerState.logout = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.OPERATION_LOGOUT,
        callback : callback
    });
};

/**
 * @deprecated Use readUserState instead - Removal after September 1 2017
 */
brainCloudClient.playerState.readPlayerState = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.OPERATION_READ,
        callback : callback
    });
};


/**
 * Read the state of the currently logged in user.
 * This method returns a JSON object describing most of the
 * user's data: entities, statistics, level, currency.
 * Apps will typically call this method after authenticating to get an
 * up-to-date view of the user's data.
 *
 * Service Name - PlayerState
 * Service Operation - Read
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerState.readUserState = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.OPERATION_READ,
        callback : callback
    });
};

/**
* Remove user's attributes.
*
* Service Name - PlayerState
* Service Operation - RemoveAttributes
*
* @param attributes Json array of attribute names.
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.playerState.removeAttributes = function(attributes, callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.REMOVE_ATTRIBUTES,
        data : {
            attributes : attributes
        },
        callback : callback
    });
};

/**
 * @deprecated Use resetUser instead - Removal after September 1 2017
 */
brainCloudClient.playerState.resetPlayer = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.OPERATION_GAME_DATA_RESET,
        callback : callback
    });
};

/**
 * This method will delete *most* data for the currently logged in user.
 * Data which is not deleted includes: currency, credentials, and
 * purchase transactions. ResetUser is different from DeleteUser in that
 * the user record will continue to exist after the reset (so the user
 * does not need to re-authenticate).
 *
 * Service Name - PlayerState
 * Service Operation - DataReset
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerState.resetUser = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.OPERATION_GAME_DATA_RESET,
        callback : callback
    });
};

/**
* Update user's attributes.
*
* Service Name - PlayerState
* Service Operation - UpdateAttributes
*
* @param attributes Single layer json string that is a set of key-value pairs
* @param wipeExisting Whether to wipe existing attributes prior to update.
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.playerState.updateAttributes = function(attributes,
        wipeExisting, callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.UPDATE_ATTRIBUTES,
        data : {
            attributes : attributes,
            wipeExisting : wipeExisting
        },
        callback : callback
    });
};

/**
 * @deprecated Use updateUserName instead - Removal after September 1 2017
 */
brainCloudClient.playerState.updatePlayerName = function(name, callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.OPERATION_UPDATE_NAME,
        data : {
            playerName : name
        },
        callback : callback
    });
};

/**
* Sets the user name.
*
* Service Name - playerState
* Service Operation - UPDATE_NAME
*
* @param name The name of the user
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.playerState.updateUserName = function(name, callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYERSTATE,
        operation : brainCloudClient.playerState.OPERATION_UPDATE_NAME,
        data : {
            playerName : name
        },
        callback : callback
    });
};


/**
 * Updates the "friend summary data" associated with the logged in user.
 * Some operations will return this summary data. For instance the social
 * leaderboards will return the player's score in the leaderboard along
 * with the friend summary data. Generally this data is used to provide
 * a quick overview of the player without requiring a separate API call
 * to read their public stats or entity data.
 *
 * Service Name - PlayerState
 * Service Operation - UpdateSummary
 *
 * @param friendSummaryData A JSON string defining the summary data.
 * For example:
 * {
 *   "xp":123,
 *   "level":12,
 *   "highScore":45123
 * }
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.playerState.updateSummaryFriendData = function(summaryFriendData, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PLAYERSTATE,
        operation: brainCloudClient.playerState.OPERATION_UPDATE_SUMMARY,
        data: {
            summaryFriendData: summaryFriendData
        },
        callback: callback
    });
};

/**
 * @deprecated Use updateUserPictureUrl instead - Removal after September 1 2017
 */
brainCloudClient.playerState.updatePlayerPictureUrl = function(pictureUrl, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PLAYERSTATE,
        operation: brainCloudClient.playerState.UPDATE_PICTURE_URL,
        data: {
            playerPictureUrl: pictureUrl
        },
        callback: callback
    });
}

/**
 * Update User picture URL.
 *
 * Service Name - PlayerState
 * Service Operation - UPDATE_PICTURE_URL
 *
 * @param pictureUrl URL to apply
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerState.updateUserPictureUrl = function(pictureUrl, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PLAYERSTATE,
        operation: brainCloudClient.playerState.UPDATE_PICTURE_URL,
        data: {
            playerPictureUrl: pictureUrl
        },
        callback: callback
    });
}

/**
 * Update the user's contact email.
 * Note this is unrelated to email authentication.
 *
 * Service Name - PlayerState
 * Service Operation - UPDATE_CONTACT_EMAIL
 *
 * @param contactEmail Updated email
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerState.updateContactEmail = function(contactEmail, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PLAYERSTATE,
        operation: brainCloudClient.playerState.UPDATE_CONTACT_EMAIL,
        data: {
            contactEmail: contactEmail
        },
        callback: callback
    });
}

/**
 * @status - complete
 */

brainCloudClient.playerStatistics = {};

brainCloudClient.SERVICE_PLAYER_STATISTICS = "playerStatistics";

brainCloudClient.playerStatistics.READ = "READ";
brainCloudClient.playerStatistics.READ_SUBSET = "READ_SUBSET";
brainCloudClient.playerStatistics.READ_SHARED = "READ_SHARED";
brainCloudClient.playerStatistics.READ_FOR_CATEGORY = "READ_FOR_CATEGORY";
brainCloudClient.playerStatistics.RESET = "RESET";
brainCloudClient.playerStatistics.UPDATE = "UPDATE";
brainCloudClient.playerStatistics.UPDATE_INCREMENT = "UPDATE_INCREMENT";
brainCloudClient.playerStatistics.UPDATE_SET_MINIMUM = "UPDATE_SET_MINIMUM";
brainCloudClient.playerStatistics.UPDATE_INCREMENT_TO_MAXIMUM = "UPDATE_INCREMENT_TO_MAXIMUM";
brainCloudClient.playerStatistics.OPERATION_PROCESS_STATISTICS = "PROCESS_STATISTICS";

brainCloudClient.playerStatistics.OPERATION_READ_NEXT_XPLEVEL = "READ_NEXT_XPLEVEL";

brainCloudClient.playerStatistics.OPERATION_SET_XPPOINTS = "SET_XPPOINTS";

/**
 * Returns JSON representing the next experience level for the user.
 *
 * Service Name - PlayerStatistics
 * Service Operation - ReadNextXpLevel
     *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerStatistics.getNextExperienceLevel = function(
        callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
                operation : brainCloudClient.playerStatistics.OPERATION_READ_NEXT_XPLEVEL,
                callback : callback
            });
};

/**
 * Increments the user's experience. If the user goes up a level,
 * the new level details will be returned along with a list of rewards.
 *
 * Service Name - PlayerStatistics
 * Service Operation - UpdateIncrement
 *
 * @param xp The amount to increase the user's experience by
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerStatistics.incrementExperiencePoints = function(xp,
        callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
                operation : brainCloudClient.playerStatistics.UPDATE,
                data : {
                    xp_points : xp
                },
                callback : callback
            });
};

/**
 * @deprecated Use incrementUserStats instead - Removal after September 1 2017
 */
brainCloudClient.playerStatistics.incrementPlayerStats = function(stats,
                                                                  xp, callback) {
    brainCloudManager
        .sendRequest({
            service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
            operation : brainCloudClient.playerStatistics.UPDATE,
            data : {
                statistics : stats,
                xp_points : xp
            },
            callback : callback
        });
};

/**
 * Atomically increment (or decrement) user statistics.
 * Any rewards that are triggered from user statistic increments
 * will be considered. User statistics are defined through the brainCloud portal.
 * Note also that the "xpCapped" property is returned (true/false depending on whether
 * the xp cap is turned on and whether the user has hit it).
 *
 * Service Name - PlayerStatistics
 * Service Operation - Update
 *
 * @param stats The JSON encoded data to be sent to the server as follows:
 * {
 *   stat1: 10,
 *   stat2: -5.5,
 * }
 * would increment stat1 by 10 and decrement stat2 by 5.5.
 * For the full statistics grammar see the api.braincloudservers.com site.
 * There are many more complex operations supported such as:
 * {
 *   stat1:INC_TO_LIMIT#9#30
 * }
 * which increments stat1 by 9 up to a limit of 30.
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerStatistics.incrementUserStats = function(stats,
                                                                xp, callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
                operation : brainCloudClient.playerStatistics.UPDATE,
                data : {
                    statistics : stats,
                    xp_points : xp
                },
                callback : callback
            });
};

/**
 * @deprecated Use readAllUserStats instead - Removal after September 1 2017
 */
brainCloudClient.playerStatistics.readAllPlayerStats = function(callback) {
    brainCloudManager
        .sendRequest({
            service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
            operation : brainCloudClient.playerStatistics.READ,
            callback : callback
        });
};

/**
 * Read all available user statistics.
 *
 * Service Name - PlayerStatistics
 * Service Operation - Read
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerStatistics.readAllUserStats = function(callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
                operation : brainCloudClient.playerStatistics.READ,
                callback : callback
            });
};

/**
 * @deprecated Use readUserStatsSubset instead - Removal after September 1 2017
 */
brainCloudClient.playerStatistics.readPlayerStatsSubset = function(subset,
                                                                   callback) {
    brainCloudManager
        .sendRequest({
            service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
            operation : brainCloudClient.playerStatistics.READ_SUBSET,
            data : {
                statistics : subset
            },
            callback : callback
        });
};

/**
 * Reads a subset of user statistics as defined by the input JSON.
 *
 * Service Name - PlayerStatistics
 * Service Operation - ReadSubset
 *
 * @param subset The json data containing the subset of statistics to read:
 *        ex. [ "pantaloons", "minions" ]
 * @param in_callback The method to be invoked when the server response is received
 *
 * @return JSON with the subset of global statistics:
 * {
 *   "status":200,
 *   "data":{
 *     "statistics":{
 *       "wood":11,
 *       "minions":1
 *     }
 *   }
 * }
 */
brainCloudClient.playerStatistics.readUserStatsSubset = function(subset,
                                                                 callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
                operation : brainCloudClient.playerStatistics.READ_SUBSET,
                data : {
                    statistics : subset
                },
                callback : callback
            });
};

/**
 * @deprecated Use readUserStatsForCategory instead - Removal after September 1 2017
 */
brainCloudClient.playerStatistics.readPlayerStatsForCategory = function(category, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PLAYER_STATISTICS,
        operation: brainCloudClient.playerStatistics.READ_FOR_CATEGORY,
        data: {
            category: category
        },
        callback: callback
    });
};

/**
 * Method retrieves the user statistics for the given category.
 *
 * Service Name - PlayerStatistics
 * Service Operation - READ_FOR_CATEGORY
 *
 * @param category The user statistics category
 * @param callback Method to be invoked when the server response is received.
 */
brainCloudClient.playerStatistics.readUserStatsForCategory = function(category, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PLAYER_STATISTICS,
        operation: brainCloudClient.playerStatistics.READ_FOR_CATEGORY,
        data: {
            category: category
        },
        callback: callback
    });
};

/**
 * @deprecated Use resetAllUserStats instead - Removal after September 1 2017
 */
brainCloudClient.playerStatistics.resetAllPlayerStats = function(callback) {
    brainCloudManager
        .sendRequest({
            service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
            operation : brainCloudClient.playerStatistics.RESET,
            callback : callback
        });
};

/**
 * Reset all of the statistics for this user back to their initial value.
 *
 * Service Name - PlayerStatistics
 * Service Operation - Reset
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerStatistics.resetAllUserStats = function(callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
                operation : brainCloudClient.playerStatistics.RESET,
                callback : callback
            });
};

/**
 * Sets the user's experience to an absolute value. Note that this
 * is simply a set and will not reward the user if their level changes
 * as a result.
 *
 * Service Name - PlayerStatistics
 * Service Operation - SetXpPoints
 *
 * @param xp The amount to set the the user's experience to
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerStatistics.setExperiencePoints = function(xp,
        callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
        operation : brainCloudClient.playerStatistics.OPERATION_SET_XPPOINTS,
        data : {
            xp_points : xp
        },
        callback : callback
    });
};

/**
* Apply statistics grammar to a partial set of statistics.
*
* Service Name - PlayerStatistics
* Service Operation - PROCESS_STATISTICS
*
* @param jsonData The JSON format is as follows:
* {
*     "DEAD_CATS": "RESET",
*     "LIVES_LEFT": "SET#9",
*     "MICE_KILLED": "INC#2",
*     "DOG_SCARE_BONUS_POINTS": "INC#10",
*     "TREES_CLIMBED": 1
* }
* @param callback Method to be invoked when the server response is received.
*/
brainCloudClient.playerStatistics.processStatistics = function(stats, callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_PLAYER_STATISTICS,
        operation : brainCloudClient.globalStatistics.OPERATION_PROCESS_STATISTICS,
        data : {
            statistics : stats
        },
        callback : callback
    });
};

brainCloudClient.playerStatisticsEvent = {};

brainCloudClient.SERVICE_PLAYER_STATISTICS_EVENT = "playerStatisticsEvent";

brainCloudClient.playerStatisticsEvent.OPERATION_TRIGGER = "TRIGGER";
brainCloudClient.playerStatisticsEvent.OPERATION_TRIGGER_MULTIPLE = "TRIGGER_MULTIPLE";

/**
 * @deprecated Use triggerUserStatsEvents instead - Removal after September 1 2017
 */
brainCloudClient.playerStatisticsEvent.triggerPlayerStatisticsEvent = function(eventName, eventMultiplier, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PLAYER_STATISTICS_EVENT,
        operation: brainCloudClient.playerStatisticsEvent.OPERATION_TRIGGER,
        data: {
            eventName : eventName,
            eventMultiplier : eventMultiplier
        },
        callback: callback
    });
};

/**
 * Trigger an event server side that will increase the users statistics.
 * This may cause one or more awards to be sent back to the user -
 * could be achievements, experience, etc. Achievements will be sent by this
 * client library to the appropriate awards service (Apple Game Center, etc).
 * 
 * This mechanism supersedes the PlayerStatisticsService API methods, since
 * PlayerStatisticsService API method only update the raw statistics without
 * triggering the rewards.
 *          
 * Service Name - PlayerStatisticsEvent
 * Service Operation - Trigger
 *
 * @see BrainCloudPlayerStatistics
 * 
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.playerStatisticsEvent.triggerUserStatsEvent = function(eventName, eventMultiplier, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PLAYER_STATISTICS_EVENT,
        operation: brainCloudClient.playerStatisticsEvent.OPERATION_TRIGGER,
        data: {
            eventName : eventName,
            eventMultiplier : eventMultiplier
        },
        callback: callback
    });
};

/**
 * @deprecated Use triggerUserStatsEvents instead - Removal after September 1 2017
 */
brainCloudClient.playerStatisticsEvent.triggerPlayerStatisticsEvents = function(events, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PLAYER_STATISTICS_EVENT,
        operation: brainCloudClient.playerStatisticsEvent.OPERATION_TRIGGER_MULTIPLE,
        data: {
            events : events
        },
        callback: callback
    });
};

/**
 * See documentation for TriggerPlayerStatisticsEvent for more
 * documentation.
 *
 * Service Name - PlayerStatisticsEvent
 * Service Operation - TriggerMultiple
 *
 * @param events
 *   [
 *     {
 *       "eventName": "event1",
 *       "eventMultiplier": 1
 *     },
 *     {
 *       "eventName": "event2",
 *       "eventMultiplier": 1
 *     }
 *   ]
 */
brainCloudClient.playerStatisticsEvent.triggerUserStatsEvents = function(events, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PLAYER_STATISTICS_EVENT,
        operation: brainCloudClient.playerStatisticsEvent.OPERATION_TRIGGER_MULTIPLE,
        data: {
            events : events
        },
        callback: callback
    });
};brainCloudClient.product = {};

brainCloudClient.SERVICE_PRODUCT = "product";

brainCloudClient.product.OPERATION_GET_INVENTORY = "GET_INVENTORY";
brainCloudClient.product.OPERATION_CASH_IN_RECEIPT = "OP_CASH_IN_RECEIPT";
brainCloudClient.product.OPERATION_CONFIRM_GOOGLEPLAY_PURCHASE = "CONFIRM_GOOGLEPLAY_PURCHASE";
brainCloudClient.product.OPERATION_AWARD_VC = "AWARD_VC";
brainCloudClient.product.OPERATION_GET_PLAYER_VC = "GET_PLAYER_VC";
brainCloudClient.product.OPERATION_RESET_PLAYER_VC = "RESET_PLAYER_VC";
brainCloudClient.product.OPERATION_CONSUME_PLAYER_VC = "CONSUME_VC";

brainCloudClient.product.OPERATION_START_STEAM_TRANSACTION = "START_STEAM_TRANSACTION";
brainCloudClient.product.OPERATION_FINALIZE_STEAM_TRANSACTION = "FINALIZE_STEAM_TRANSACTION";
brainCloudClient.product.OPERATION_VERIFY_MICROSOFT_RECEIPT = "VERIFY_MICROSOFT_RECEIPT";
brainCloudClient.product.OPERATION_ELIGIBLE_PROMOTIONS = "ELIGIBLE_PROMOTIONS";
brainCloudClient.product.OPERATION_CASH_IN_RECEIPT = "OP_CASH_IN_RECEIPT";
brainCloudClient.product.OPERATION_FB_CONFIRM_PURCHASE = "FB_CONFIRM_PURCHASE";
brainCloudClient.product.OPERATION_GOOGLEPLAY_CONFIRM_PURCHASE = "GOOGLEPLAY_CONFIRM_PURCHASE";

/**
 * Method gets the active sales inventory for the passed-in platform and
 * currency type.
 *
 * Service Name - Product
 * Service Operation - GetInventory
 *
 * @param platform The store platform. Valid stores are:
 * - itunes
 * - facebook
 * - appworld
 * - steam
 * - windows
 * - windowsPhone
 * - googlePlay
 * @param userCurrency The currency to retrieve the sales
 * inventory for. This is only used for Steam and Facebook stores.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.product.getSalesInventory = function(platform, userCurrency, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_GET_INVENTORY,
        data: {
            platform: platform,
            user_currency : userCurrency
        },
        callback: callback
    });
};

/**
 * Method gets the active sales inventory for the passed-in platform,
 * currency type and category.
 *
 * Service Name - Product
 * Service Operation - GetInventory
 *
 * @param platform The store platform. Valid stores are:
 * - itunes
 * - facebook
 * - appworld
 * - steam
 * - windows
 * - windowsPhone
 * - googlePlay
 * @param userCurrency The currency to retrieve the sales
 * inventory for. This is only used for Steam and Facebook stores.
 * @param category Inventory category to retrieve
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.product.getSalesInventoryByCategory = function(platform, userCurrency, category, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_GET_INVENTORY,
        data: {
            platform: platform,
            user_currency : userCurrency,
            category : category
        },
        callback: callback
    });
};


/**
 * Method verifies an iTunes receipt and awards the items related to this receipt.
 *
 * Service Name - Product
 * Server Operation - OP_CASH_IN_RECEIPT
 *
 * @param base64EncReceiptData The iTunes receipt
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.product.verifyItunesReceipt = function(base64EncReceiptData, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_CASH_IN_RECEIPT,
        data: {
            receipt: base64EncReceiptData
        },
        callback: callback
    });
};

/**
 * Confirms a google play purchase. On success, the player will be awarded the
 * associated currencies.
 *
 * Service Name - Product
 * Server Operation - CONFIRM_GOOGLEPLAY_PURCHASE
 *
 * @param productId The product id
 * @param token Google Play token string
 * @param orderId The order id
 * @param callback The method to be invoked when the server response is received
 * @return The JSON returned in the callback is as follows:
 * {
 *   "status": 200,
 *   "data":
 *   {
 *      "result" : "OK"
 *   }
 * }
 */
brainCloudClient.product.confirmGooglePlayPurchase = function(productId, token, orderId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_CONFIRM_GOOGLEPLAY_PURCHASE,
        data: {
            productId: productId,
            token: token,
            orderId: orderId
        },
        callback: callback
    });
};

/**
 * Gets the player's currency for the given currency type
 * or all currency types if null passed in.
 *
 * Service Name - Product
 * Service Operation - GetPlayerVC
 *
 * @param currencyType The currency type to retrieve or null
 * if all currency types are being requested.
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.product.getCurrency = function(currencyType, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_GET_PLAYER_VC,
        data: {
            vc_id: currencyType
        },
        callback: callback
    });
};

/**
 * @deprecated Method is recommended to be used in Cloud Code only for security
 * If you need to use it client side, enable 'Allow Currency Calls from Client' on the brainCloud dashboard
 */
brainCloudClient.product.awardCurrency = function(currencyType, amount, callback) {
    var message = {
            vc_id: currencyType,
            vc_amount: amount
    };
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_AWARD_VC,
        data: message,
        callback: callback
    });
};

/**
 * @deprecated Method is recommended to be used in Cloud Code only for security
 * If you need to use it client side, enable 'Allow Currency Calls from Client' on the brainCloud dashboard
 */
brainCloudClient.product.resetCurrency = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_RESET_PLAYER_VC,
        callback: callback
    });
};

/**
 * @deprecated Method is recommended to be used in Cloud Code only for security
 * If you need to use it client side, enable 'Allow Currency Calls from Client' on the brainCloud dashboard
 */
brainCloudClient.product.consumeCurrency = function(vcId, amount, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_CONSUME_PLAYER_VC,
        data: {
            vc_id: vcId,
            vc_amount: amount
        },
        callback: callback
    });
};

/**
 * Get Eligible Promotions
 *
 * Service Name - Product
 * Service Operation - GetEligiblePromotions
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.product.getEligiblePromotions = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_ELIGIBLE_PROMOTIONS,
        callback: callback
    });
};

/**
 * Initialize Steam Transaction
 *
 * Service Name - Product
 * Service Operation - StartSteamTransaction
 *
 * @param language ISO 639-1 language code
 * @param items Items to purchase
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.product.startSteamTransaction = function(language, itemId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_START_STEAM_TRANSACTION,
        data: {
            language: language,
            itemId: itemId
        },
        callback: callback
    });
};

/**
 * Finalize Steam Transaction. On success, the player will be awarded the
 * associated currencies.
 *
 * Service Name - Product
 * Service Operation - FinalizeSteamTransaction
 *
 * @param transId Steam transaction id
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.product.finalizeSteamTransaction = function(transId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_FINALIZE_STEAM_TRANSACTION,
        data: {
            transId: transId
        },
        callback: callback
    });
};

/**
 * Verify Microsoft Receipt. On success, the player will be awarded the
 * associated currencies.
 *
 * Service Name - Product
 * Service Operation - VerifyMicrosoftReceipt
 *
 * @param receipt Receipt XML
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.product.verifyMicrosoftReceipt = function(receipt, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_VERIFY_MICROSOFT_RECEIPT,
        data: {
            receipt: receipt
        },
        callback: callback
    });
};

/**
 * Confirm Facebook Purchase. On success, the player will be awarded the
 * associated currencies.
 *
 * Service Name - Product
 * Service Operation - FB_CONFIRM_PURCHASE
 *
 * @param signedRequest Signed_request object received from Facebook
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.product.confirmFacebookPurchase = function(signedRequest, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PRODUCT,
        operation: brainCloudClient.product.OPERATION_FB_CONFIRM_PURCHASE,
        data: {
            signed_request: signedRequest
        },
        callback: callback
    });
};

brainCloudClient.profanity = {};

brainCloudClient.SERVICE_PROFANITY = "profanity";

brainCloudClient.profanity.OPERATION_PROFANITY_CHECK = "PROFANITY_CHECK";
brainCloudClient.profanity.OPERATION_PROFANITY_REPLACE_TEXT = "PROFANITY_REPLACE_TEXT";
brainCloudClient.profanity.OPERATION_PROFANITY_IDENTIFY_BAD_WORDS = "PROFANITY_IDENTIFY_BAD_WORDS";

/**
 * Checks supplied text for profanity.
 *
 * Service Name - Profanity
 * Service Operation - ProfanityCheck
 *
 * @param text The text to check
 * @param languages Optional comma delimited list of two character language codes
 * @param flagEmail Optional processing of email addresses
 * @param flagPhone Optional processing of phone numbers
 * @param flagUrls Optional processing of urls
 * @param callback The method to be invoked when the server response is received
 *
 * Significant error codes:
 *
 * 40421 - WebPurify not configured
 * 40422 - General exception occurred
 * 40423 - WebPurify returned an error (Http status != 200)
 * 40424 - WebPurify not enabled
 */
brainCloudClient.profanity.profanityCheck = function(text, languages, flagEmail, flagPhone, flagUrls, callback) {
    var data = {};
    data["text"] = text;
    if (languages != null)
    {
        data["languages"] = languages;
    }
    data["flagEmail"] = flagEmail;
    data["flagPhone"] = flagPhone;
    data["flagUrls"] = flagUrls;
        
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PROFANITY,
        operation: brainCloudClient.profanity.OPERATION_PROFANITY_CHECK,
        data: data,
        callback: callback
    });
};



/**
 * Replaces the characters of profanity text with a passed character(s).
 *
 * Service Name - Profanity
 * Service Operation - ProfanityReplaceText
 *
 * @param text The text to check
 * @param replaceSymbol The text to replace individual characters of profanity text with
 * @param languages Optional comma delimited list of two character language codes
 * @param flagEmail Optional processing of email addresses
 * @param flagPhone Optional processing of phone numbers
 * @param flagUrls Optional processing of urls
 * @param callback The method to be invoked when the server response is received
 *
 * Significant error codes:
 *
 * 40421 - WebPurify not configured
 * 40422 - General exception occurred
 * 40423 - WebPurify returned an error (Http status != 200)
 * 40424 - WebPurify not enabled
 */
brainCloudClient.profanity.profanityReplaceText = function(text, replaceSymbol, languages, flagEmail, flagPhone, flagUrls, callback) {
    var data = {};
    data["text"] = text;
    data["replaceSymbol"] = replaceSymbol;
    if (languages != null)
    {
        data["languages"] = languages;
    }
    data["flagEmail"] = flagEmail;
    data["flagPhone"] = flagPhone;
    data["flagUrls"] = flagUrls;
        
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PROFANITY,
        operation: brainCloudClient.profanity.OPERATION_PROFANITY_REPLACE_TEXT,
        data: data,
        callback: callback
    });
};


/**
 * Checks supplied text for profanity and returns a list of bad wors.
 *
 * Service Name - Profanity
 * Service Operation - ProfanityIdentifyBadWords
 *
 * @param in_text The text to check
 * @param in_languages Optional comma delimited list of two character language codes
 * @param in_flagEmail Optional processing of email addresses
 * @param in_flagPhone Optional processing of phone numbers
 * @param in_flagUrls Optional processing of urls
 * @param in_callback The method to be invoked when the server response is received
 *
 * Significant error codes:
 *
 * 40421 - WebPurify not configured
 * 40422 - General exception occurred
 * 40423 - WebPurify returned an error (Http status != 200)
 * 40424 - WebPurify not enabled
 */
brainCloudClient.profanity.profanityIdentifyBadWords = function(text, languages, flagEmail, flagPhone, flagUrls, callback) {
    var data = {};
    data["text"] = text;
    if (languages != null)
    {
        data["languages"] = languages;
    }
    data["flagEmail"] = flagEmail;
    data["flagPhone"] = flagPhone;
    data["flagUrls"] = flagUrls;
        
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PROFANITY,
        operation: brainCloudClient.profanity.OPERATION_PROFANITY_IDENTIFY_BAD_WORDS,
        data: data,
        callback: callback
    });
};
brainCloudClient.pushNotification = {};

brainCloudClient.SERVICE_PUSH_NOTIFICATION = "pushNotification";

brainCloudClient.pushNotification.OPERATION_DEREGISTER_ALL = "DEREGISTER_ALL";
brainCloudClient.pushNotification.OPERATION_DEREGISTER = "DEREGISTER";
brainCloudClient.pushNotification.OPERATION_SEND_SIMPLE = "SEND_SIMPLE";
brainCloudClient.pushNotification.OPERATION_SEND_RICH = "SEND_RICH";
brainCloudClient.pushNotification.OPERATION_SEND_RAW = "SEND_RAW";
brainCloudClient.pushNotification.OPERATION_SEND_RAW_TO_GROUP = "SEND_RAW_TO_GROUP";
brainCloudClient.pushNotification.OPERATION_SEND_RAW_BATCH = "SEND_RAW_BATCH";
brainCloudClient.pushNotification.OPERATION_REGISTER = "REGISTER";
brainCloudClient.pushNotification.OPERATION_SEND_NORMALIZED_TO_GROUP = "SEND_NORMALIZED_TO_GROUP";
brainCloudClient.pushNotification.OPERATION_SEND_TEMPLATED_TO_GROUP = "SEND_TEMPLATED_TO_GROUP";
brainCloudClient.pushNotification.OPERATION_SEND_NORMALIZED = "SEND_NORMALIZED";
brainCloudClient.pushNotification.OPERATION_SEND_NORMALIZED_BATCH = "SEND_NORMALIZED_BATCH";
brainCloudClient.pushNotification.OPERATION_SCHEDULED_RICH = "SCHEDULE_RICH_NOTIFICATION";
brainCloudClient.pushNotification.OPERATION_SCHEDULED_NORMALIZED = "SCHEDULE_NORMALIZED_NOTIFICATION"
brainCloudClient.pushNotification.OPERATION_SCHEDULED_RAW = "SCHEDULE_RAW_NOTIFICATION"

/**
* Deregisters all device tokens currently registered to the user.
*
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.deregisterAllPushNotificationDeviceTokens = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_DEREGISTER_ALL,
        data: {},
        callback: callback
    });
};

/**
* Deregisters the given device token from the server to disable this device
* from receiving push notifications.
*
* @param deviceType The device platform being deregistered.
* @param deviceToken The platform-dependant device token
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.deregisterPushNotificationDeviceToken = function(deviceType, deviceToken, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_DEREGISTER,
        data: {
            deviceType: deviceType,
            deviceToken: deviceToken
        },
        callback: callback
    });
};

/**
* Registers the given device token with the server to enable this device
* to receive push notifications.
*
* @param deviceType The type of device (see DEVICE_TYPE_* constants)
* @param deviceToken The platform-dependant device token needed for push notifications.
*   On IOS, this is obtained using the application:didRegisterForRemoteNotificationsWithDeviceToken callback
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.registerPushNotificationToken = function(deviceType, deviceToken, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_REGISTER,
        data: {
            deviceType: deviceType,
            deviceToken: deviceToken
        },
        callback: callback
    });
};

/**
* Sends a simple push notification based on the passed in message.
* NOTE: It is possible to send a push notification to oneself.
*
* @param toProfileId The braincloud profileId of the user to receive the notification
* @param message Text of the push notification
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.sendSimplePushNotification = function(toProfileId, message, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SEND_SIMPLE,
        data: {
            toPlayerId: toProfileId,
            message: message
        },
        callback: callback
    });
};

/**
* Sends a notification to a user based on a brainCloud portal configured notification template.
* NOTE: It is possible to send a push notification to oneself.
*
* @param toProfileId The braincloud profileId of the user to receive the notification
* @param notificationTemplateId Id of the notification template
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.sendRichPushNotification = function(toProfileId, notificationTemplateId, callback) {
    brainCloudClient.pushNotification.sendRichPushNotificationWithParams(toProfileId, notificationTemplateId, null, callback);
};

/**
* Sends a notification to a user based on a brainCloud portal configured notification template.
* Includes JSON defining the substitution params to use with the template.
* See the Portal documentation for more info.
* NOTE: It is possible to send a push notification to oneself.
*
* @param toProfileId The braincloud profileId of the user to receive the notification
* @param notificationTemplateId Id of the notification template
* @param substitutionJson JSON defining the substitution params to use with the template
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.sendRichPushNotificationWithParams = function(toProfileId, notificationTemplateId, substitutionJson, callback) {
    var data = {
        toPlayerId: toProfileId,
        notificationTemplateId: notificationTemplateId
    };

    if (substitutionJson) {
        data.substitutions = substitutionJson;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SEND_RICH,
        data: data,
        callback: callback
    });
};

/**
* Sends a notification to a "group" of user based on a brainCloud portal configured notification template.
* Includes JSON defining the substitution params to use with the template.
* See the Portal documentation for more info.
*
* @param groupId Target group
* @param notificationTemplateId Template to use
* @param substitutionJson Map of substitution positions to strings
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.sendTemplatedPushNotificationToGroup = function(groupId, notificationTemplateId, substitutionJson, callback) {
    var data = {
        groupId: groupId,
        notificationTemplateId: notificationTemplateId
    };

    if (substitutionJson) data.substitutions = substitutionJson;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SEND_TEMPLATED_TO_GROUP,
        data: data,
        callback: callback
    });
}

/**
* Sends a notification to a "group" of user consisting of alert content and custom data.
* See the Portal documentation for more info.
*
* @param groupId Target group
* @param alertContentJson Body and title of alert
* @param customDataJson Optional custom data
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.sendNormalizedPushNotificationToGroup = function(groupId, alertContentJson, customDataJson, callback) {
    var data = {
        groupId: groupId,
        alertContent: alertContentJson
    };

    if (customDataJson) data.customData = customDataJson;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SEND_NORMALIZED_TO_GROUP,
        data: data,
        callback: callback
    });
}

/**
* Schedules raw notifications based on user local time.
*
* @param profileId The profileId of the user to receive the notification
* @param fcmContent Valid Fcm data content
* @param iosContent Valid ios data content
* @param facebookContent Facebook template string
* @param startTime Start time of sending the push notification
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.scheduleRawPushNotificationUTC = function(profileId, fcmContent, iosContent, facebookContent, startTime, callback) {
    var data = {
        profileId: profileId,
        startDateUTC: startTime
    };

    if (fcmContent) data.fcmContent = fcmContent;
    if (iosContent) data.iosContent = iosContent;
    if (facebookContent) data.facebookContent = facebookContent;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SCHEDULED_RAW,
        data: data,
        callback: callback
    });
}

/**
* Schedules raw notifications based on user local time.
*
* @param profileId The profileId of the user to receive the notification
* @param fcmContent Valid Fcm data content
* @param iosContent Valid ios data content
* @param facebookContent Facebook template string
* @param minutesFromNow Minutes from now to send the push notification
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.scheduleRawPushNotificationMinutes = function(profileId, fcmContent, iosContent, facebookContent, minutesFromNow, callback) {
    var data = {
        profileId: profileId,
        minutesFromNow: minutesFromNow
    };

    if (fcmContent) data.fcmContent = fcmContent;
    if (iosContent) data.iosContent = iosContent;
    if (facebookContent) data.facebookContent = facebookContent;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SCHEDULED_RAW,
        data: data,
        callback: callback
    });
}

/**
 * Sends a raw push notification to a target user.
 *
 * @param toProfileId The profileId of the user to receive the notification
 * @param fcmContent Valid Fcm data content
 * @param iosContent Valid ios data content
 * @param facebookContent Facebook template string
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.pushNotification.sendRawPushNotification = function(toProfileId, fcmContent, iosContent, facebookContent, callback) {
    var data = {
        toPlayerId : toProfileId
    };

    if (fcmContent) data.fcmContent = fcmContent;
    if (iosContent) data.iosContent = iosContent;
    if (facebookContent) data.facebookContent = facebookContent;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SEND_RAW,
        data: data,
        callback: callback
    });
}

/**
 * Sends a raw push notification to a target list of users.
 *
 * @param profileIds Collection of profile IDs to send the notification to
 * @param fcmContent Valid Fcm data content
 * @param iosContent Valid ios data content
 * @param facebookContent Facebook template string
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.pushNotification.sendRawPushNotificationBatch = function(profileIds, fcmContent, iosContent, facebookContent, callback) {
    var data = {
        profileIds: profileIds
    };

    if (fcmContent) data.fcmContent = fcmContent;
    if (iosContent) data.iosContent = iosContent;
    if (facebookContent) data.facebookContent = facebookContent;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SEND_RAW_BATCH,
        data: data,
        callback: callback
    });
}

/**
 * Sends a raw push notification to a target group.
 *
 * @param groupId Target group
 * @param fcmContent Valid Fcm data content
 * @param iosContent Valid ios data content
 * @param facebookContent Facebook template string
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.pushNotification.sendRawPushNotificationToGroup = function(groupId, fcmContent, iosContent, facebookContent, callback) {
    var data = {
        groupId: groupId
    };

    if (fcmContent) data.fcmContent = fcmContent;
    if (iosContent) data.iosContent = iosContent;
    if (facebookContent) data.facebookContent = facebookContent;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SEND_RAW_TO_GROUP,
        data: data,
        callback: callback
    });
}

/**
 * Schedules a normalized push notification to a user
 *
 * @param profileId The profileId of the user to receive the notification
 * @param alertContentJson Body and title of alert
 * @param customDataJson Optional custom data
 * @param startTime Start time of sending the push notification
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.pushNotification.scheduleNormalizedPushNotificationUTC = function(profileId, alertContentJson, customDataJson, startTime, callback) {
    var data = {
        profileId: profileId,
        alertContent: alertContentJson,
        startDateUTC: startTime
    };

    if (customDataJson) {
        data.customData = customDataJson;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SCHEDULED_NORMALIZED,
        data: data,
        callback: callback
    });
};

/**
 * Schedules a normalized push notification to a user
 *
 * @param profileId The profileId of the user to receive the notification
 * @param alertContentJson Body and title of alert
 * @param customDataJson Optional custom data
 * @param minutesFromNow Minutes from now to send the push notification
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.pushNotification.scheduleNormalizedPushNotificationMinutes = function(profileId, alertContentJson, customDataJson, minutesFromNow, callback) {
    var data = {
        profileId: profileId,
        alertContent: alertContentJson,
        minutesFromNow: minutesFromNow
    };

    if (customDataJson) {
        data.customData = customDataJson;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SCHEDULED_NORMALIZED,
        data: data,
        callback: callback
    });
};

/**
 * Schedules a rich push notification to a user
 *
 * @param profileId The profileId of the user to receive the notification
 * @param notificationTemplateId Body and title of alert
 * @param substitutionJson Map of substitution positions to strings
 * @param startTime Start time of sending the push notification
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.pushNotification.scheduleRichPushNotificationUTC = function(profileId, notificationTemplateId, substitutionJson, startTime, callback) {
    var data = {
        profileId: profileId,
        notificationTemplateId: notificationTemplateId,
        startDateUTC: startTime
    };

    if (substitutionJson) {
        data.substitutions = substitutionJson;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SCHEDULED_RICH,
        data: data,
        callback: callback
    });
};

/**
 * Schedules a rich push notification to a user
 *
 * @param profileId The profileId of the user to receive the notification
 * @param notificationTemplateId Body and title of alert
 * @param substitutionJson Map of substitution positions to strings
 * @param minutesFromNow Minutes from now to send the push notification
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.pushNotification.scheduleRichPushNotificationMinutes = function(profileId, notificationTemplateId, substitutionJson, minutesFromNow, callback) {
    var data = {
        profileId: profileId,
        notificationTemplateId: notificationTemplateId,
        minutesFromNow: minutesFromNow
    };

    if (substitutionJson) {
        data.substitutions = substitutionJson;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SCHEDULED_RICH,
        data: data,
        callback: callback
    });
};

/**
* Sends a notification to a user consisting of alert content and custom data.
*
* @param toProfileId The profileId of the user to receive the notification
* @param alertContentJson Body and title of alert
* @param customDataJson Optional custom data
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.sendNormalizedPushNotification = function(toProfileId, alertContentJson, customDataJson, callback) {
    var data = {
        toPlayerId: toProfileId,
        alertContent: alertContentJson
    };

    if (customDataJson) data.customData = customDataJson;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SEND_NORMALIZED,
        data: data,
        callback: callback
    });
}

/**
* Sends a notification to multiple users consisting of alert content and custom data.
*
* @param profileIds Collection of profile IDs to send the notification to
* @param alertContentJson Body and title of alert
* @param customDataJson Optional custom data
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.pushNotification.sendNormalizedPushNotificationBatch = function(profileIds, alertContentJson, customDataJson, callback) {
    var data = {
        profileIds: profileIds,
        alertContent: alertContentJson
    };

    if (customDataJson) data.customData = customDataJson;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_PUSH_NOTIFICATION,
        operation: brainCloudClient.pushNotification.OPERATION_SEND_NORMALIZED_BATCH,
        data: data,
        callback: callback
    });
}

brainCloudClient.reasonCodes = {};

brainCloudClient.reasonCodes.NO_REASON_CODE = 0;

brainCloudClient.reasonCodes.INVALID_NOTIFICATION = 20200;

brainCloudClient.reasonCodes.INVALID_REQUEST = 40001;

//  brainCloudClient.reasonCodes.CREATING_FACEBOOK_MEMORY = 40200;
brainCloudClient.reasonCodes.SWITCHING_FACEBOOK_MEMORY = 40201;
brainCloudClient.reasonCodes.MERGING_MEMORY = 40202;
brainCloudClient.reasonCodes.RECREATING_ANONYMOUS_MEMORY = 40203;
brainCloudClient.reasonCodes.MOVING_ANONYMOUS_MEMORY = 40204;
brainCloudClient.reasonCodes.LOGIN_SECURITY_ERROR = 40205;
brainCloudClient.reasonCodes.MISSING_IDENTITY_ERROR = 40206;
brainCloudClient.reasonCodes.SWITCHING_PROFILES = 40207;
brainCloudClient.reasonCodes.MISSING_PROFILE_ERROR = 40208;
brainCloudClient.reasonCodes.SECURITY_ERROR = 40209;
brainCloudClient.reasonCodes.DOWNGRADING_TO_ANONYMOUS_ERROR = 40210;
brainCloudClient.reasonCodes.DUPLICATE_IDENTITY_TYPE = 40211;
brainCloudClient.reasonCodes.MERGE_PROFILES = 40212;
brainCloudClient.reasonCodes.INVALID_PROPERTY_NAME = 40213;
brainCloudClient.reasonCodes.EMAIL_NOT_VALIDATED = 40214;

// Forbidden (403)...
brainCloudClient.reasonCodes.UNABLE_TO_GET_FRIENDS_FROM_FACEBOOK = 40300;
brainCloudClient.reasonCodes.BAD_SIGNATURE = 40301;
brainCloudClient.reasonCodes.UNABLE_TO_VALIDATE_PLAYER = 40302;
brainCloudClient.reasonCodes.UNABLE_TO_VALIDATE_USER = brainCloudClient.reasonCodes.UNABLE_TO_VALIDATE_PLAYER;
brainCloudClient.reasonCodes.PLAYER_SESSION_EXPIRED = 40303;
brainCloudClient.reasonCodes.USER_SESSION_EXPIRED = brainCloudClient.reasonCodes.PLAYER_SESSION_EXPIRED;
brainCloudClient.reasonCodes.NO_SESSION = 40304;
brainCloudClient.reasonCodes.PLAYER_SESSION_MISMATCH = 40305;
brainCloudClient.reasonCodes.USER_SESSION_MISMATCH = brainCloudClient.reasonCodes.PLAYER_SESSION_MISMATCH;
brainCloudClient.reasonCodes.OPERATION_REQUIRES_A_SESSION = 40306;
brainCloudClient.reasonCodes.TOKEN_DOES_NOT_MATCH_USER = 40307;
brainCloudClient.reasonCodes.EVENT_CAN_ONLY_SEND_TO_FRIEND_OR_SELF = 40309;
brainCloudClient.reasonCodes.NOT_FRIENDS = 40310;
brainCloudClient.reasonCodes.VC_BALANCE_CANNOT_BE_SPECIFIED = 40311;
brainCloudClient.reasonCodes.VC_LIMIT_EXCEEDED = 40312;
brainCloudClient.reasonCodes.UNABLE_TO_GET_MY_DATA_FROM_FACEBOOK = 40313;
brainCloudClient.reasonCodes.INVALID_AUTHENTICATION_TYPE = 40315;
brainCloudClient.reasonCodes.INVALID_GAME_ID = 40316;
brainCloudClient.reasonCodes.INVALID_APP_ID = brainCloudClient.reasonCodes.INVALID_GAME_ID;
brainCloudClient.reasonCodes.APPLE_TRANS_ID_ALREADY_CLAIMED = 40317;
brainCloudClient.reasonCodes.CLIENT_VERSION_NOT_SUPPORTED = 40318;
brainCloudClient.reasonCodes.BRAINCLOUD_VERSION_NOT_SUPPORTED = 40319;
brainCloudClient.reasonCodes.PLATFORM_NOT_SUPPORTED = 40320;
brainCloudClient.reasonCodes.INVALID_PLAYER_STATISTICS_EVENT_NAME = 40321;
brainCloudClient.reasonCodes.GAME_VERSION_NOT_SUPPORTED = 40322;
brainCloudClient.reasonCodes.GAME_VERSION_NOT_SUPPORTED = brainCloudClient.reasonCodes.GAME_VERSION_NOT_SUPPORTED;
brainCloudClient.reasonCodes.BAD_REFERENCE_DATA = 40324;
brainCloudClient.reasonCodes.MISSING_OAUTH_TOKEN = 40325;
brainCloudClient.reasonCodes.MISSING_OAUTH_VERIFIER = 40326;
brainCloudClient.reasonCodes.MISSING_OAUTH_TOKEN_SECRET = 40327;
brainCloudClient.reasonCodes.MISSING_TWEET = 40328;
brainCloudClient.reasonCodes.FACEBOOK_PAYMENT_ID_ALREADY_PROCESSED = 40329;
brainCloudClient.reasonCodes.DISABLED_GAME = 40330;
brainCloudClient.reasonCodes.DISABLED_APP = brainCloudClient.reasonCodes.DISABLED_GAME;
brainCloudClient.reasonCodes.MATCH_MAKING_DISABLED = 40331;
brainCloudClient.reasonCodes.UPDATE_FAILED = 40332;
brainCloudClient.reasonCodes.INVALID_OPERATION = 40333; // invalid operation for API call
brainCloudClient.reasonCodes.MATCH_RANGE_ERROR = 40334;
brainCloudClient.reasonCodes.PLAYER_IN_MATCH = 40335;
brainCloudClient.reasonCodes.MATCH_PLAYER_SHIELDED = 40336;
brainCloudClient.reasonCodes.MATCH_PLAYER_MISSING = 40337;
brainCloudClient.reasonCodes.MATCH_PLAYER_LOGGED_IN = 40338;
brainCloudClient.reasonCodes.INVALID_ITEM_ID = 40339;
brainCloudClient.reasonCodes.MISSING_PRICE = 40340;
brainCloudClient.reasonCodes.MISSING_USER_INFO = 40341;
brainCloudClient.reasonCodes.MISSING_STEAM_RESPONSE = 40342;
brainCloudClient.reasonCodes.MISSING_STEAM_TRANSACTION = 40343;
brainCloudClient.reasonCodes.ENTITY_VERSION_MISMATCH = 40344;
brainCloudClient.reasonCodes.MISSING_RECORD = 40345;
brainCloudClient.reasonCodes.INSUFFICIENT_PERMISSIONS = 40346;
brainCloudClient.reasonCodes.MISSING_IN_QUERY = 40347;
brainCloudClient.reasonCodes.RECORD_EXPIRED = 40348;
brainCloudClient.reasonCodes.INVALID_WHERE = 40349;
brainCloudClient.reasonCodes.S3_ERROR = 40350;
brainCloudClient.reasonCodes.INVALID_ATTRIBUTES = 40351;
brainCloudClient.reasonCodes.IMPORT_MISSING_GAME_DATA = 40352;
brainCloudClient.reasonCodes.IMPORT_MISSING_APP_DATA = brainCloudClient.reasonCodes.IMPORT_MISSING_GAME_DATA;
brainCloudClient.reasonCodes.IMPORT_SCHEMA_VERSION_TOO_OLD = 40353;
brainCloudClient.reasonCodes.IMPORT_SCHEMA_VERSION_INVALID = 40355;
brainCloudClient.reasonCodes.PLAYER_SESSION_LOGGED_OUT = 40356;
brainCloudClient.reasonCodes.USER_SESSION_LOGGED_OUT = brainCloudClient.reasonCodes.PLAYER_SESSION_LOGGED_OUT;
brainCloudClient.reasonCodes.API_HOOK_SCRIPT_ERROR = 40357;
brainCloudClient.reasonCodes.MISSING_REQUIRED_PARAMETER = 40358;
brainCloudClient.reasonCodes.INVALID_PARAMETER_TYPE = 40359;
brainCloudClient.reasonCodes.INVALID_IDENTITY_TYPE = 40360;
brainCloudClient.reasonCodes.EMAIL_SEND_ERROR = 40361;
brainCloudClient.reasonCodes.CHILD_ENTITY_PARTIAL_UPDATE_INVALID_DATA = 40362;
brainCloudClient.reasonCodes.MISSING_SCRIPT = 40363;
brainCloudClient.reasonCodes.SCRIPT_SECURITY_ERROR = 40364;
brainCloudClient.reasonCodes.SERVER_SESSION_EXPIRED = 40365;
brainCloudClient.reasonCodes.STREAM_DOES_NOT_EXIT = 40366;
brainCloudClient.reasonCodes.STREAM_ACCESS_ERROR = 40367;
brainCloudClient.reasonCodes.STREAM_COMPLETE = 40368;
brainCloudClient.reasonCodes.INVALID_STATISTIC_NAME = 40369;
brainCloudClient.reasonCodes.INVALID_HTTP_REQUEST = 40370;
brainCloudClient.reasonCodes.GAME_LIMIT_REACHED = 40371;
brainCloudClient.reasonCodes.APP_LIMIT_REACHED = brainCloudClient.reasonCodes.GAME_LIMIT_REACHED;
brainCloudClient.reasonCodes.GAME_RUNSTATE_DISABLED = 40372;
brainCloudClient.reasonCodes.APP_RUNSTATE_DISABLED = brainCloudClient.reasonCodes.GAME_RUNSTATE_DISABLED;
brainCloudClient.reasonCodes.INVALID_COMPANY_ID = 40373;
brainCloudClient.reasonCodes.INVALID_PLAYER_ID = 40374;
brainCloudClient.reasonCodes.INVALID_USER_ID = brainCloudClient.reasonCodes.INVALID_PLAYER_ID;
brainCloudClient.reasonCodes.INVALID_TEMPLATE_ID = 40375;
brainCloudClient.reasonCodes.MINIMUM_SEARCH_INPUT = 40376;
brainCloudClient.reasonCodes.MISSING_GAME_PARENT = 40377;
brainCloudClient.reasonCodes.MISSING_APP_PARENT = brainCloudClient.reasonCodes.MISSING_GAME_PARENT;
brainCloudClient.reasonCodes.GAME_PARENT_MISMATCH = 40378;
brainCloudClient.reasonCodes.APP_PARENT_MISMATCH = brainCloudClient.reasonCodes.GAME_PARENT_MISMATCH;
brainCloudClient.reasonCodes.CHILD_PLAYER_MISSING = 40379;
brainCloudClient.reasonCodes.CHILD_USER_MISSING = brainCloudClient.reasonCodes.CHILD_PLAYER_MISSING;
brainCloudClient.reasonCodes.MISSING_PLAYER_PARENT = 40380;
brainCloudClient.reasonCodes.MISSING_USER_PARENT = brainCloudClient.reasonCodes.MISSING_PLAYER_PARENT;
brainCloudClient.reasonCodes.PLAYER_PARENT_MISMATCH = 40381;
brainCloudClient.reasonCodes.USER_PARENT_MISMATCH = brainCloudClient.reasonCodes.PLAYER_PARENT_MISMATCH;
brainCloudClient.reasonCodes.MISSING_PLAYER_ID = 40382;
brainCloudClient.reasonCodes.MISSING_USER_ID = brainCloudClient.reasonCodes.MISSING_PLAYER_ID;
brainCloudClient.reasonCodes.DECODE_CONTEXT = 40383;
brainCloudClient.reasonCodes.INVALID_QUERY_CONTEXT = 40384;
brainCloudClient.reasonCodes.GROUP_MEMBER_NOT_FOUND = 40385;
brainCloudClient.reasonCodes.INVALID_SORT = 40386;
brainCloudClient.reasonCodes.GAME_NOT_FOUND = 40387;
brainCloudClient.reasonCodes.APP_NOT_FOUND = brainCloudClient.reasonCodes.GAME_NOT_FOUND;
brainCloudClient.reasonCodes.GAMES_NOT_IN_SAME_COMPANY = 40388;
brainCloudClient.reasonCodes.APPS_NOT_IN_SAME_COMPANY = brainCloudClient.reasonCodes.GAMES_NOT_IN_SAME_COMPANY;
brainCloudClient.reasonCodes.IMPORT_NO_PARENT_ASSIGNED = 40389;
brainCloudClient.reasonCodes.IMPORT_PARENT_CURRENCIES_MISMATCH = 40390;
brainCloudClient.reasonCodes.INVALID_SUBSTITUION_ENTRY = 40391;
brainCloudClient.reasonCodes.INVALID_TEMPLATE_STRING = 40392;
brainCloudClient.reasonCodes.TEMPLATE_SUBSTITUTION_ERROR = 40393;
brainCloudClient.reasonCodes.INVALID_OPPONENTS = 40394;
brainCloudClient.reasonCodes.REDEMPTION_CODE_NOT_FOUND = 40395;
brainCloudClient.reasonCodes.REDEMPTION_CODE_VERSION_MISMATCH = 40396;
brainCloudClient.reasonCodes.REDEMPTION_CODE_ACTIVE = 40397;
brainCloudClient.reasonCodes.REDEMPTION_CODE_NOT_ACTIVE = 40398;
brainCloudClient.reasonCodes.REDEMPTION_CODE_TYPE_NOT_FOUND = 40399;
brainCloudClient.reasonCodes.REDEMPTION_CODE_INVALID = 40400;
brainCloudClient.reasonCodes.REDEMPTION_CODE_REDEEMED = 40401;
brainCloudClient.reasonCodes.REDEMPTION_CODE_REDEEMED_BY_SELF = 40402;
brainCloudClient.reasonCodes.REDEMPTION_CODE_REDEEMED_BY_OTHER = 40403;
brainCloudClient.reasonCodes.SCRIPT_EMPTY = 40404;
brainCloudClient.reasonCodes.ITUNES_COMMUNICATION_ERROR = 40405;
brainCloudClient.reasonCodes.ITUNES_NO_RESPONSE = 40406;
brainCloudClient.reasonCodes.ITUNES_RESPONSE_NOT_OK = 40407;
brainCloudClient.reasonCodes.JSON_PARSING_ERROR = 40408;
brainCloudClient.reasonCodes.ITUNES_NULL_RESPONSE = 40409;
brainCloudClient.reasonCodes.ITUNES_RESPONSE_WITH_NULL_STATUS = 40410;
brainCloudClient.reasonCodes.ITUNES_STATUS_BAD_JSON_RECEIPT = 40411;
brainCloudClient.reasonCodes.ITUNES_STATUS_BAD_RECEIPT = 40412;
brainCloudClient.reasonCodes.ITUNES_STATUS_RECEIPT_NOT_AUTHENTICATED = 40413;
brainCloudClient.reasonCodes.ITUNES_STATUS_BAD_SHARED_SECRET = 40414;
brainCloudClient.reasonCodes.ITUNES_STATUS_RECEIPT_SERVER_UNAVAILABLE = 40415;
brainCloudClient.reasonCodes.ITUNES_RECEIPT_MISSING_ITUNES_PRODUCT_ID = 40416;
brainCloudClient.reasonCodes.PRODUCT_NOT_FOUND_FOR_ITUNES_PRODUCT_ID = 40417;
brainCloudClient.reasonCodes.DATA_STREAM_EVENTS_NOT_ENABLED = 40418;
brainCloudClient.reasonCodes.INVALID_DEVICE_TOKEN = 40419;
brainCloudClient.reasonCodes.ERROR_DELETING_DEVICE_TOKEN = 40420;
brainCloudClient.reasonCodes.WEBPURIFY_NOT_CONFIGURED = 40421;
brainCloudClient.reasonCodes.WEBPURIFY_EXCEPTION = 40422;
brainCloudClient.reasonCodes.WEBPURIFY_FAILURE = 40423;
brainCloudClient.reasonCodes.WEBPURIFY_NOT_ENABLED = 40424;
brainCloudClient.reasonCodes.NAME_CONTAINS_PROFANITY = 40425;
brainCloudClient.reasonCodes.NULL_SESSION = 40426;
brainCloudClient.reasonCodes.PURCHASE_ALREADY_VERIFIED = 40427;
brainCloudClient.reasonCodes.GOOGLE_IAP_NOT_CONFIGURED = 40428;
brainCloudClient.reasonCodes.UPLOAD_FILE_TOO_LARGE = 40429;
brainCloudClient.reasonCodes.FILE_ALREADY_EXISTS = 40430;
brainCloudClient.reasonCodes.CLOUD_STORAGE_SERVICE_ERROR = 40431;
brainCloudClient.reasonCodes.FILE_DOES_NOT_EXIST = 40432;
brainCloudClient.reasonCodes.UPLOAD_ID_MISSING = 40433;
brainCloudClient.reasonCodes.UPLOAD_JOB_MISSING = 40434;
brainCloudClient.reasonCodes.UPLOAD_JOB_EXPIRED = 40435;
brainCloudClient.reasonCodes.UPLOADER_EXCEPTION = 40436;
brainCloudClient.reasonCodes.UPLOADER_FILESIZE_MISMATCH = 40437;
brainCloudClient.reasonCodes.PUSH_NOTIFICATIONS_NOT_CONFIGURED = 40438;
brainCloudClient.reasonCodes.MATCHMAKING_FILTER_SCRIPT_FAILURE = 40439;
brainCloudClient.reasonCodes.ACCOUNT_ALREADY_EXISTS = 40440;
brainCloudClient.reasonCodes.PROFILE_ALREADY_EXISTS = 40441;
brainCloudClient.reasonCodes.MISSING_NOTIFICATION_BODY = 40442;
brainCloudClient.reasonCodes.INVALID_SERVICE_CODE = 40443;
brainCloudClient.reasonCodes.IP_ADDRESS_BLOCKED = 40444;
brainCloudClient.reasonCodes.UNAPPROVED_SERVICE_CODE = 40445;
brainCloudClient.reasonCodes.PROFILE_NOT_FOUND = 40446;
brainCloudClient.reasonCodes.ENTITY_NOT_SHARED = 40447;
brainCloudClient.reasonCodes.SELF_FRIEND = 40448;
brainCloudClient.reasonCodes.PARSE_NOT_CONFIGURED = 40449;
brainCloudClient.reasonCodes.PARSE_NOT_ENABLED = 40450;
brainCloudClient.reasonCodes.PARSE_REQUEST_ERROR = 40451;
brainCloudClient.reasonCodes.GROUP_CANNOT_ADD_OWNER = 40452;
brainCloudClient.reasonCodes.NOT_GROUP_MEMBER = 40453;
brainCloudClient.reasonCodes.INVALID_GROUP_ROLE = 40454;
brainCloudClient.reasonCodes.GROUP_OWNER_DELETE = 40455;
brainCloudClient.reasonCodes.NOT_INVITED_GROUP_MEMBER = 40456;
brainCloudClient.reasonCodes.GROUP_IS_FULL = 40457;
brainCloudClient.reasonCodes.GROUP_OWNER_CANNOT_LEAVE = 40458;
brainCloudClient.reasonCodes.INVALID_INCREMENT_VALUE = 40459;
brainCloudClient.reasonCodes.GROUP_VERSION_MISMATCH = 40460;
brainCloudClient.reasonCodes.GROUP_ENTITY_VERSION_MISMATCH = 40461;
brainCloudClient.reasonCodes.INVALID_GROUP_ID = 40462;
brainCloudClient.reasonCodes.INVALID_FIELD_NAME = 40463;
brainCloudClient.reasonCodes.UNSUPPORTED_AUTH_TYPE = 40464;
brainCloudClient.reasonCodes.CLOUDCODE_JOB_NOT_FOUND = 40465;
brainCloudClient.reasonCodes.CLOUDCODE_JOB_NOT_SCHEDULED = 40466;
brainCloudClient.reasonCodes.GROUP_TYPE_NOT_FOUND = 40467;
brainCloudClient.reasonCodes.MATCHING_GROUPS_NOT_FOUND = 40468;
brainCloudClient.reasonCodes.GENERATE_CDN_URL_ERROR = 40469;
brainCloudClient.reasonCodes.INVALID_PROFILE_IDS = 40470;
brainCloudClient.reasonCodes.MAX_PROFILE_IDS_EXCEEDED = 40471;
brainCloudClient.reasonCodes.PROFILE_ID_MISMATCH = 40472;
brainCloudClient.reasonCodes.LEADERBOARD_DOESNOT_EXIST = 40473;
brainCloudClient.reasonCodes.APP_LICENSING_EXCEEDED = 40474;
brainCloudClient.reasonCodes.SENDGRID_NOT_INSTALLED = 40475;
brainCloudClient.reasonCodes.SENDGRID_EMAIL_SEND_ERROR = 40476;
brainCloudClient.reasonCodes.SENDGRID_NOT_ENABLED_FOR_APP = 40477;
brainCloudClient.reasonCodes.SENDGRID_GET_TEMPLATES_ERROR = 40478;
brainCloudClient.reasonCodes.SENDGRID_INVALID_API_KEY = 40479;
brainCloudClient.reasonCodes.EMAIL_SERVICE_NOT_CONFIGURED = 40480;
brainCloudClient.reasonCodes.INVALID_EMAIL_TEMPLATE_TYPE = 40481;
brainCloudClient.reasonCodes.SENDGRID_KEY_EMPTY_OR_NULL = 40482;
brainCloudClient.reasonCodes.BODY_TEMPLATE_CANNOT_COEXIST = 40483;
brainCloudClient.reasonCodes.SUBSTITUTION_BODY_CANNOT_COEXIST = 40484;
brainCloudClient.reasonCodes.INVALID_FROM_ADDRESS = 40485;
brainCloudClient.reasonCodes.INVALID_FROM_NAME = 40486;
brainCloudClient.reasonCodes.INVALID_REPLY_TO_ADDRESS = 40487;
brainCloudClient.reasonCodes.INVALID_REPLY_TO_NAME = 40488;
brainCloudClient.reasonCodes.FROM_NAME_WITHOUT_FROM_ADDRESS = 40489;
brainCloudClient.reasonCodes.REPLY_TO_NAME_WITHOUT_REPLY_TO_ADDRESS = 40490;
brainCloudClient.reasonCodes.CURRENCY_SECURITY_ERROR = 40491;
brainCloudClient.reasonCodes.INVALID_PEER_CODE = 40492;
brainCloudClient.reasonCodes.PEER_NO_LONGER_EXISTS = 40493;

brainCloudClient.reasonCodes.CANNOT_MODIFY_TOURNAMENT_WITH_LEADERBOARD_SERVICE = 40494;
brainCloudClient.reasonCodes.NO_TOURNAMENT_ASSOCIATED_WITH_LEADERBOARD = 40495;
brainCloudClient.reasonCodes.TOURNAMENT_NOT_ASSOCIATED_WITH_LEADERBOARD = 40496;
brainCloudClient.reasonCodes.PLAYER_ALREADY_TOURNAMENT_FOR_LEADERBOARD = 40497;
brainCloudClient.reasonCodes.PLAYER_EARLY_FOR_JOINING_TOURNAMENT = 40498;
brainCloudClient.reasonCodes.NO_LEADERBOARD_FOUND = 40499;
brainCloudClient.reasonCodes.PLAYER_NOT_IN_TIME_RANGE_FOR_POSTSCORE_TOURNAMENT = 40500;
brainCloudClient.reasonCodes.LEADERBOARD_ID_BAD = 40501;
brainCloudClient.reasonCodes.SCORE_INPUT_BAD = 40502;
brainCloudClient.reasonCodes.ROUND_STARTED_EPOCH_INPUT_BAD = 40503;
brainCloudClient.reasonCodes.TOURNAMENT_CODE_INPUT_BAD = 40504;
brainCloudClient.reasonCodes.PLAYER_NOT_ENROLLED_IN_TOURNAMENT = 40505;
brainCloudClient.reasonCodes.LEADERBOARD_VERSION_ID_INVALID = 40506;
brainCloudClient.reasonCodes.NOT_ENOUGH_BALANCE_TO_JOIN_TOURNAMENT = 40507;
brainCloudClient.reasonCodes.PARENT_ALREADY_ATTACHED = 40508;
brainCloudClient.reasonCodes.PEER_ALREADY_ATTACHED = 40509;
brainCloudClient.reasonCodes.IDENTITY_NOT_ATTACHED_WITH_PARENT = 40510;
brainCloudClient.reasonCodes.IDENTITY_NOT_ATTACHED_WITH_PEER = 40511;
brainCloudClient.reasonCodes.LEADERBOARD_SCORE_UPDATE_ERROR = 40512;
brainCloudClient.reasonCodes.ERROR_CLAIMING_REWARD = 40513;
brainCloudClient.reasonCodes.NOT_ENOUGH_PARENT_BALANCE_TO_JOIN_TOURNAMENT = 40514;
brainCloudClient.reasonCodes.NOT_ENOUGH_PEER_BALANCE_TO_JOIN_TOURNAMENT = 40515;
brainCloudClient.reasonCodes.PLAYER_LATE_FOR_JOINING_TOURNAMENT = 40516;
brainCloudClient.reasonCodes.VIEWING_REWARD_FOR_NON_PROCESSED_TOURNAMENTS = 40517;
brainCloudClient.reasonCodes.NO_REWARD_ASSOCIATED_WITH_LEADERBOARD = 40518;
brainCloudClient.reasonCodes.PROFILE_PEER_NOT_FOUND = 40519;
brainCloudClient.reasonCodes.LEADERBOARD_IN_ACTIVE_STATE = 40520;
brainCloudClient.reasonCodes.LEADERBOARD_IN_CALCULATING_STATE = 40521;
brainCloudClient.reasonCodes.TOURNAMENT_RESULT_PROCESSING_FAILED = 40522;
brainCloudClient.reasonCodes.TOURNAMENT_REWARDS_ALREADY_CLAIMED = 40523;
brainCloudClient.reasonCodes.NO_TOURNAMENT_FOUND = 40524;
brainCloudClient.reasonCodes.UNEXPECTED_ERROR_RANK_ZERO_AFTER_PROCESSING = 40525;
brainCloudClient.reasonCodes.UNEXPECTED_ERROR_DELETING_TOURNAMENT_LEADERBOARD_SCORE = 40526;
brainCloudClient.reasonCodes.INVALID_RUN_STATE = 40527;
brainCloudClient.reasonCodes.LEADERBOARD_SCORE_DOESNOT_EXIST = 40528;
brainCloudClient.reasonCodes.INITIAL_SCORE_NULL = 40529;
brainCloudClient.reasonCodes.TOURNAMENT_NOTIFICATIONS_PROCESSING_FAILED = 40530;
brainCloudClient.reasonCodes.ACL_NOT_READABLE = 40531;
brainCloudClient.reasonCodes.INVALID_OWNER_ID = 40532;
brainCloudClient.reasonCodes.IMPORT_MISSING_PEERS_DATA = 40533;
brainCloudClient.reasonCodes.INVALID_CREDENTIAL = 40534;

brainCloudClient.reasonCodes.NO_TWITTER_CONSUMER_KEY = 500001;
brainCloudClient.reasonCodes.NO_TWITTER_CONSUMER_SECRET = 500002;
brainCloudClient.reasonCodes.INVALID_CONFIGURATION = 500003;
brainCloudClient.reasonCodes.ERROR_GETTING_REQUEST_TOKEN = 500004;
brainCloudClient.reasonCodes.ERROR_GETTING_ACCESS_TOKEN = 500005;

brainCloudClient.reasonCodes.FACEBOOK_ERROR = 500010;
brainCloudClient.reasonCodes.FACEBOOK_SECRET_MISMATCH = 500011;
brainCloudClient.reasonCodes.FACEBOOK_AUTHENTICATION_ERROR = 500012;
brainCloudClient.reasonCodes.FACEBOOK_APPLICATION_TOKEN_REQUEST_ERROR = 500013;
brainCloudClient.reasonCodes.FACEBOOK_BAD_APPLICATION_TOKEN_SIGNATURE = 500014;

brainCloudClient.reasonCodes.CLIENT_NETWORK_ERROR_TIMEOUT = 90001;
brainCloudClient.reasonCodes.CLIENT_UPLOAD_FILE_CANCELLED = 90100;
brainCloudClient.reasonCodes.CLIENT_UPLOAD_FILE_TIMED_OUT = 90101;
brainCloudClient.reasonCodes.CLIENT_UPLOAD_FILE_UNKNOWN = 90102;
brainCloudClient.reasonCodes.CLIENT_DISABLED = 90200;

brainCloudClient.redemptionCode = {};

brainCloudClient.SERVICE_REDEMPTION_CODE = "redemptionCode";

brainCloudClient.redemptionCode.OPERATION_REDEEM_CODE = "REDEEM_CODE";
brainCloudClient.redemptionCode.OPERATION_GET_REDEEMED_CODES = "GET_REDEEMED_CODES";

/**
 * Redeem a code.
 *  
 * Service Name - RedemptionCode
 * Service Operation - REDEEM_CODE
 *
 * @param scanCode The code to redeem
 * @param codeType The type of code
 * @param jsonCustomRedemptionInfo Optional - A JSON object containing custom redemption data
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.redemptionCode.redeemCode = function(scanCode, codeType, jsonCustomRedemptionInfo, callback) 
{    
    var data = {
        scanCode : scanCode,
        codeType : codeType
    };  

    if(jsonCustomRedemptionInfo) {
        data.customRedemptionInfo = jsonCustomRedemptionInfo;
    }
  
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_REDEMPTION_CODE,
        operation: brainCloudClient.redemptionCode.OPERATION_REDEEM_CODE,
        data: data,
        callback: callback
    });
};

/**
 * Retrieve the codes already redeemed by player.
 *  
 * Service Name - RedemptionCode
 * Service Operation - GET_REDEEMED_CODES
 *
 * @param codeType Optional - The type of codes to retrieve. Returns all codes if left unspecified.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.redemptionCode.getRedeemedCodes = function(codeType, callback) 
{    
    var data = {};  

    if(codeType) {
        data.codeType = codeType;
    }

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_REDEMPTION_CODE,
        operation: brainCloudClient.redemptionCode.OPERATION_GET_REDEEMED_CODES,
        data: data,
        callback: callback
    });
};
brainCloudClient.s3Handling = {};

brainCloudClient.SERVICE_S3HANDLING = "s3Handling";

brainCloudClient.s3Handling.OPERATION_GET_FILE_LIST = "GET_FILE_LIST";
brainCloudClient.s3Handling.OPERATION_GET_UPDATED_FILES = "GET_UPDATED_FILES";
brainCloudClient.s3Handling.OPERATION_GET_CDN_URL = "GET_CDN_URL";

/*
 * Sends an array of file details and returns
 * the details of any of those files that have changed
 *
 * Service Name - S3Handling
 * Service Operation - GetUpdatedFiles
 *
 * @param category  Category of files on server to compare against
 * @param fileDetailsJson  An array of file details
 * @param callback  Instance of IServerCallback to call when the server response is received
 */
brainCloudClient.s3Handling.getUpdatedFiles = function(category, fileDetails, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_S3HANDLING,
        operation: brainCloudClient.s3Handling.OPERATION_GET_UPDATED_FILES,
        data: {
            category : category,
            fileDetails : fileDetails
        },
        callback: callback
    });
};

/*
 * Retrieves the details of custom files stored on the server
 *
 * Service Name - S3Handling
 * Service Operation - GetUpdatedFiles
 *
 * @param category  Category of files to retrieve
 * @param callback  Instance of IServerCallback to call when the server response is received
 */
brainCloudClient.s3Handling.getFileList = function(category, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_S3HANDLING,
        operation: brainCloudClient.s3Handling.OPERATION_GET_FILE_LIST,
        data: {
            category : category
        },
        callback: callback
    });
};

/**
 * Returns the CDN url for a file
 *
 * @param fileId ID of file
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.s3Handling.getCDNUrl = function(fileId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_S3HANDLING,
        operation: brainCloudClient.s3Handling.OPERATION_GET_CDN_URL,
        data: {
            fileId : fileId
        },
        callback: callback
    });
};

brainCloudClient.script = {};

brainCloudClient.SERVICE_SCRIPT = "script";

brainCloudClient.script.OPERATION_RUN = "RUN";
brainCloudClient.script.OPERATION_SCHEDULE_CLOUD_SCRIPT = "SCHEDULE_CLOUD_SCRIPT";
brainCloudClient.script.OPERATION_RUN_PARENT_SCRIPT = "RUN_PARENT_SCRIPT";
brainCloudClient.script.OPERATION_CANCEL_SCHEDULED_SCRIPT = "CANCEL_SCHEDULED_SCRIPT";
brainCloudClient.script.OPERATION_RUN_PEER_SCRIPT = "RUN_PEER_SCRIPT";
brainCloudClient.script.OPERATION_RUN_PEER_SCRIPT_ASYNC = "RUN_PEER_SCRIPT_ASYNC";


/**
 * Executes a script on the server.
 *
 * Service Name - Script
 * Service Operation - Run
 *
 * @param scriptName The name of the script to be run
 * @param scriptData Data to be sent to the script in json format
 * @param callback The method to be invoked when the server response is received
 * @see The API documentation site for more details on cloud code
 */
brainCloudClient.script.runScript = function(scriptName, scriptData, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_SCRIPT,
        operation: brainCloudClient.script.OPERATION_RUN,
        data: {
            scriptName: scriptName,
            scriptData: scriptData
        },
        callback: callback
    });
};

/**
 * Allows cloud script executions to be scheduled
 *
 * Service Name - Script
 * Service Operation - ScheduleCloudScript
 *
 * @param scriptName The name of the script to be run
 * @param scriptData Data to be sent to the script in json format
 * @param startDateInUTC A date Object representing the time and date to run the script
 * @param callback The method to be invoked when the server response is received
 * @see The API documentation site for more details on cloud code
 */
brainCloudClient.script.scheduleRunScriptUTC = function(scriptName, scriptData, startDateInUTC, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_SCRIPT,
        operation: brainCloudClient.script.OPERATION_SCHEDULE_CLOUD_SCRIPT,
        data: {
            scriptName: scriptName,
            scriptData: scriptData,
            startDateUTC: startDateInUTC.getTime()
        },
        callback: callback
    });
};

/**
 * Allows cloud script executions to be scheduled
 *
 * Service Name - Script
 * Service Operation - ScheduleCloudScript
 *
 * @param scriptName The name of the script to be run
 * @param scriptData Data to be sent to the script in json format
 * @param minutesFromNow Number of minutes from now to run script
 * @param callback The method to be invoked when the server response is received
 * @see The API documentation site for more details on cloud code
 */
brainCloudClient.script.scheduleRunScriptMinutes = function(scriptName, scriptData, minutesFromNow, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_SCRIPT,
        operation: brainCloudClient.script.OPERATION_SCHEDULE_CLOUD_SCRIPT,
        data: {
            scriptName: scriptName,
            scriptData: scriptData,
            minutesFromNow: minutesFromNow
        },
        callback: callback
    });
};

/**
 * Run a cloud script in a parent app
 *
 * Service Name - Script
 * Service Operation - RUN_PARENT_SCRIPT
 *
 * @param scriptName The name of the script to be run
 * @param scriptData Data to be sent to the script in json format
 * @param parentLevel The level name of the parent to run the script from
 * @param callback The method to be invoked when the server response is received
 * @see The API documentation site for more details on cloud code
 */
brainCloudClient.script.runParentScript = function(scriptName, scriptData, parentLevel, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_SCRIPT,
        operation: brainCloudClient.script.OPERATION_RUN_PARENT_SCRIPT,
        data: {
            scriptName: scriptName,
            scriptData: scriptData,
            parentLevel: parentLevel
        },
        callback: callback
    });
};

/**
 * Cancels a scheduled cloud code script
 *
 * Service Name - Script
 * Service Operation - CANCEL_SCHEDULED_SCRIPT
 *
 * @param jobId The scheduled script job to cancel
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.script.cancelScheduledScript = function(jobId, callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_SCRIPT,
        operation: brainCloudClient.script.OPERATION_CANCEL_SCHEDULED_SCRIPT,
        data: {
            jobId: jobId
        },
        callback: callback
    });
};

/**
 * Runs a script from the context of a peer
 *
 * Service Name - Script
 * Service Operation - RUN_PEER_SCRIPT
 *
 * @param scriptName The name of the script to be run
 * @param jsonScriptData Data to be sent to the script in json format
 * @param peer Peer the script belongs to
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.script.runPeerScript = function(scriptName, scriptData, peer, callback) {
    var message = {
        scriptName: scriptName,
        peer: peer
    };

    if(scriptData)
        message.scriptData = scriptData;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_SCRIPT,
        operation: brainCloudClient.script.OPERATION_RUN_PEER_SCRIPT,
        data: message,
        callback: callback
    });
};

/**
 * Runs a script asynchronously from the context of a peer
 * This method does not wait for the script to complete before returning
 *
 * Service Name - Script
 * Service Operation - RUN_PEER_SCRIPT_ASYNC
 *
 * @param scriptName The name of the script to be run
 * @param jsonScriptData Data to be sent to the script in json format
 * @param peer Peer the script belongs to
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.script.runPeerScriptAsync = function(scriptName, scriptData, peer, callback) {
    var message = {
        scriptName: scriptName,
        peer: peer
    };

    if(scriptData)
        message.scriptData = scriptData;

    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_SCRIPT,
        operation: brainCloudClient.script.OPERATION_RUN_PEER_SCRIPT_ASYNC,
        data: message,
        callback: callback
    });
};
/**
 * @status complete
 */
brainCloudClient.socialLeaderboard = {};

brainCloudClient.SERVICE_LEADERBOARD = "leaderboard";

brainCloudClient.socialLeaderboard.OPERATION_POST_SCORE = "POST_SCORE";
brainCloudClient.socialLeaderboard.OPERATION_POST_SCORE_DYNAMIC = "POST_SCORE_DYNAMIC";
brainCloudClient.socialLeaderboard.OPERATION_RESET = "RESET";
brainCloudClient.socialLeaderboard.OPERATION_GET_SOCIAL_LEADERBOARD = "GET_SOCIAL_LEADERBOARD";
brainCloudClient.socialLeaderboard.OPERATION_GET_MULTI_SOCIAL_LEADERBOARD = "GET_MULTI_SOCIAL_LEADERBOARD";
brainCloudClient.socialLeaderboard.OPERATION_GET_GLOBAL_LEADERBOARD_PAGE = "GET_GLOBAL_LEADERBOARD_PAGE";
brainCloudClient.socialLeaderboard.OPERATION_GET_GLOBAL_LEADERBOARD_VIEW = "GET_GLOBAL_LEADERBOARD_VIEW";
brainCloudClient.socialLeaderboard.OPERATION_GET_GLOBAL_LEADERBOARD_VERSIONS = "GET_GLOBAL_LEADERBOARD_VERSIONS";
brainCloudClient.socialLeaderboard.OPERATION_GET_GROUP_SOCIAL_LEADERBOARD = "GET_GROUP_SOCIAL_LEADERBOARD";
brainCloudClient.socialLeaderboard.OPERATION_GET_PLAYERS_SOCIAL_LEADERBOARD = "GET_PLAYERS_SOCIAL_LEADERBOARD";
brainCloudClient.socialLeaderboard.OPERATION_LIST_ALL_LEADERBOARDS = "LIST_ALL_LEADERBOARDS";
brainCloudClient.socialLeaderboard.OPERATION_GET_GLOBAL_LEADERBOARD_ENTRY_COUNT = "GET_GLOBAL_LEADERBOARD_ENTRY_COUNT";
brainCloudClient.socialLeaderboard.OPERATION_REMOVE_PLAYER_SCORE = "REMOVE_PLAYER_SCORE";
brainCloudClient.socialLeaderboard.OPERATION_GET_PLAYER_SCORE = "GET_PLAYER_SCORE";
brainCloudClient.socialLeaderboard.OPERATION_GET_PLAYER_SCORES_FROM_LEADERBOARDS = "GET_PLAYER_SCORES_FROM_LEADERBOARDS";

// Constant helper values
brainCloudClient.socialLeaderboard.leaderboardType = Object.freeze({ HIGH_VALUE : "HIGH_VALUE", CUMULATIVE : "CUMULATIVE", LAST_VALUE : "LAST_VALUE", LOW_VALUE : "LOW_VALUE"});
brainCloudClient.socialLeaderboard.rotationType = Object.freeze({ NEVER : "NEVER", DAILY : "DAILY", WEEKLY : "WEEKLY", MONTHLY : "MONTHLY", YEARLY : "YEARLY"});
brainCloudClient.socialLeaderboard.fetchType = Object.freeze({ HIGHEST_RANKED : "HIGHEST_RANKED" });
brainCloudClient.socialLeaderboard.sortOrder = Object.freeze({ HIGH_TO_LOW : "HIGH_TO_LOW",  LOW_TO_HIGH : "LOW_TO_HIGH" });


/**
 * Method returns a page of global leaderboard results.
 *
 * Leaderboards entries contain the player's score and optionally, some user-defined
 * data associated with the score.
 *
 * Note: This method allows the client to retrieve pages from within the global leaderboard list
 *
 * Service Name - SocialLeaderboard
 * Service Operation - GetGlobalLeaderboardPage
 *
 * @param leaderboardId {string} The id of the leaderboard to retrieve.
 * @param sortOrder {string} Sort key Sort order of page.
 * @param startRank {int} The rank at which to start the page.
 * @param endRank {int} The rank at which to end the page.
 * @param callback The method to be invoked when the server response is received
 *
 * @see brainCloudClient.socialLeaderboard.SortOrder
 */
brainCloudClient.socialLeaderboard.getGlobalLeaderboardPage = function(
        leaderboardId, sortOrder, startIndex, endIndex, callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_LEADERBOARD,
                operation : brainCloudClient.socialLeaderboard.OPERATION_GET_GLOBAL_LEADERBOARD_PAGE,
                data : {
                    leaderboardId : leaderboardId,
                    sort : sortOrder,
                    startIndex : startIndex,
                    endIndex : endIndex
                },
                callback : callback
            });
};

/**
 * Method returns a page of global leaderboard results.
 * By using a non-current version id, the user can retrieve a historial leaderboard.
 * See GetGlobalLeaderboardVersions method to retrieve the version id.
 *
 * Service Name - SocialLeaderboard
 * Service Operation - GetGlobalLeaderboardPage
 *
 * @param leaderboardId {string} The id of the leaderboard to retrieve.
 * @param sortOrder {string} Sort key Sort order of page.
 * @param startRank {int} The rank at which to start the page.
 * @param endRank {int} The rank at which to end the page.
 * @param versionId The historical version to retrieve
 * @param callback The method to be invoked when the server response is received
 *
 * @see brainCloudClient.socialLeaderboard.SortOrder
 */
brainCloudClient.socialLeaderboard.getGlobalLeaderboardPageByVersion = function(
        leaderboardId, sortOrder, startIndex, endIndex, versionId, callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_LEADERBOARD,
                operation : brainCloudClient.socialLeaderboard.OPERATION_GET_GLOBAL_LEADERBOARD_PAGE,
                data : {
                    leaderboardId : leaderboardId,
                    sort : sortOrder,
                    startIndex : startIndex,
                    endIndex : endIndex,
                    versionId : versionId
                },
                callback : callback
            });
};

/**
 * Method returns a view of global leaderboard results.
 *
 * Leaderboards entries contain the player's score and optionally, some user-defined
 * data associated with the score.
 *
 * Note: This method allows the client to retrieve pages from within the global leaderboard list
 *
 * Service Name - SocialLeaderboard
 * Service Operation - GetGlobalLeaderboardPage
 *
 * @param leaderboardId {string} The id of the leaderboard to retrieve.
 * @param sortOrder {string} Sort key Sort order of page.
 * @param beforeCount {int} The count of number of players before the current player to include.
 * @param afterCount {int} The count of number of players after the current player to include.
 * @param callback The method to be invoked when the server response is received
 *
 * @see brainCloudClient.socialLeaderboard.SortOrder
 */
brainCloudClient.socialLeaderboard.getGlobalLeaderboardView = function(
        leaderboardId, sortOrder, beforeCount, afterCount, callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_LEADERBOARD,
                operation : brainCloudClient.socialLeaderboard.OPERATION_GET_GLOBAL_LEADERBOARD_VIEW,
                data : {
                    leaderboardId : leaderboardId,
                    sort : sortOrder,
                    beforeCount : beforeCount,
                    afterCount : afterCount
                },
                callback : callback
            });
};

/**
 * Method returns a view of global leaderboard results.
 * By using a non-current version id, the user can retrieve a historial leaderboard.
 * See GetGlobalLeaderboardVersions method to retrieve the version id.
 *
 * Service Name - SocialLeaderboard
 * Service Operation - GetGlobalLeaderboardView
 *
 * @param leaderboardId {string} The id of the leaderboard to retrieve.
 * @param sortOrder {string} Sort key Sort order of page.
 * @param beforeCount {int} The count of number of players before the current player to include.
 * @param afterCount {int} The count of number of players after the current player to include.
 * @param versionId The historical version to retrieve
 * @param callback The method to be invoked when the server response is received
 *
 * @see brainCloudClient.socialLeaderboard.SortOrder
 */
brainCloudClient.socialLeaderboard.getGlobalLeaderboardViewByVersion = function(
        leaderboardId, sortOrder, beforeCount, afterCount, versionId, callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_LEADERBOARD,
                operation : brainCloudClient.socialLeaderboard.OPERATION_GET_GLOBAL_LEADERBOARD_VIEW,
                data : {
                    leaderboardId : leaderboardId,
                    sort : sortOrder,
                    beforeCount : beforeCount,
                    afterCount : afterCount,
                    versionId : versionId
                },
                callback : callback
            });
};

/**
 * Gets the number of entries in a global leaderboard
 *
 * Service Name - leaderboard
 * Service Operation - GET_GLOBAL_LEADERBOARD_ENTRY_COUNT
 *
 * @param leaderboardId The leaderboard ID
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.socialLeaderboard.getGlobalLeaderboardEntryCount = function(leaderboardId, callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_LEADERBOARD,
                operation : brainCloudClient.socialLeaderboard.OPERATION_GET_GLOBAL_LEADERBOARD_ENTRY_COUNT,
                data : {
                    leaderboardId : leaderboardId
                },
                callback : callback
            });
};

/**
 * Method returns the social leaderboard. A player's social leaderboard is
 * comprised of players who are recognized as being your friend.
 * For now, this applies solely to Facebook connected players who are
 * friends with the logged in player (who also must be Facebook connected).
 * In the future this will expand to other identification means (such as
 * Game Centre, Google circles etc).
 *
 * Leaderboards entries contain the player's score and optionally, some user-defined
 * data associated with the score. The currently logged in player will also
 * be returned in the social leaderboard.
 *
 * Note: If no friends have played the game, the bestScore, createdAt, updatedAt
 * will contain NULL.
 *
 * @param leaderboardId The id of the leaderboard to retrieve
 * @param replaceName If true, the currently logged in player's name will be replaced
 * by the string "You".
 * @param callback The method to be invoked when the server response is received
 *
 */
brainCloudClient.socialLeaderboard.getSocialLeaderboard = function(
        leaderboardId, replaceName, callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_LEADERBOARD,
                operation : brainCloudClient.socialLeaderboard.OPERATION_GET_SOCIAL_LEADERBOARD,
                data : {
                    leaderboardId : leaderboardId,
                    replaceName : replaceName
                },
                callback : callback
            });
};

/**
 * Reads multiple social leaderboards.
 *
 * @param leaderboardIds An array of leaderboard ID strings.
 * @param leaderboardResultCount Maximum count of entries to return for each leaderboard.
 * @param replaceName If true, the currently logged in player's name will be replaced
 * by the string "You".
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.socialLeaderboard.getMultiSocialLeaderboard = function(
        leaderboardIds, leaderboardResultCount, replaceName, callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_LEADERBOARD,
                operation : brainCloudClient.socialLeaderboard.OPERATION_GET_MULTI_SOCIAL_LEADERBOARD,
                data : {
                    leaderboardIds : leaderboardIds,
                    leaderboardResultCount : leaderboardResultCount,
                    replaceName : replaceName
                },
                callback : callback
            });
};

/** Gets the global leaderboard versions.
 *
 * Service Name - SocialLeaderboard
 * Service Operation - GetGlobalLeaderboardVersions
 *
 * @param in_leaderboardId The leaderboard
 * @param in_callback The method to be invoked when the server response is received
 */
brainCloudClient.socialLeaderboard.getGlobalLeaderboardVersions = function(leaderboardId, callback) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_LEADERBOARD,
                operation : brainCloudClient.socialLeaderboard.OPERATION_GET_GLOBAL_LEADERBOARD_VERSIONS,
                data : {
                    leaderboardId : leaderboardId
                },
                callback : callback
            });
};


/**
 * Post the players score to the given social leaderboard. You can optionally
 * send a user-defined json string of data with the posted score. This string
 * could include information relevant to the posted score.
 *
 * Note that the behaviour of posting a score can be modified in the brainCloud
 * portal. By default, the server will only keep the player's best score.
 *
 * @param leaderboardId
 *            {string} The leaderboard to post to
 * @param score
 *            {number} The score to post
 * @param otherData
 *            {json} Optional user-defined data to post with the score
 * @param callback
 *            The callback handler
 */
brainCloudClient.socialLeaderboard.postScoreToLeaderboard = function(leaderboardId, score,
        otherData, callback) {

    var message = {
        leaderboardId : leaderboardId,
        score : score
    };

    if (otherData)
    {
        message["data"] = otherData;
    }

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_LEADERBOARD,
        operation : brainCloudClient.socialLeaderboard.OPERATION_POST_SCORE,
        data : message,
        callback : callback
    });
};

/**
 * Post the players score to the given social leaderboard.
 * Pass leaderboard config data to dynamically create if necessary.
 * You can optionally send a user-defined json string of data
 * with the posted score. This string could include information
 * relevant to the posted score.
 *
 * Service Name - SocialLeaderboard
 * Service Operation - PostScoreDynamic
 *
 * @param leaderboardName The leaderboard to post to
 * @param score The score to post
 * @param data Optional user-defined data to post with the score
 * @param leaderboardType leaderboard type
 * @param rotationType Type of rotation
 * @param rotationReset A date Object representing the time and date to start rotation
 * @param retainedCount How many rotations to keep
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.socialLeaderboard.postScoreToDynamicLeaderboard = function(leaderboardName, score,
        data, leaderboardType, rotationType, rotationReset, retainedCount, callback ) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_LEADERBOARD,
                operation : brainCloudClient.socialLeaderboard.OPERATION_POST_SCORE_DYNAMIC,
                data : {
                    leaderboardId : leaderboardName,
                    score : score,
                    data : data,
                    leaderboardType : leaderboardType,
                    rotationType : rotationType,
                    rotationResetTime : rotationReset.getTime().toFixed(0),
                    retainedCount : retainedCount
                },
                callback : callback
            });
};

/**
 * Post the players score to the given social leaderboard.
 * Pass leaderboard config data to dynamically create if necessary.
 * You can optionally send a user-defined json string of data
 * with the posted score. This string could include information
 * relevant to the posted score.
 *
 * Service Name - SocialLeaderboard
 * Service Operation - PostScoreDynamic
 *
 * @param leaderboardName The leaderboard to post to
 * @param score The score to post
 * @param data Optional user-defined data to post with the score
 * @param leaderboardType leaderboard type
 * @param rotationType Type of rotation
 * @param rotationReset A date Object representing the time and date to start rotation
 * @param retainedCount How many rotations to keep
 * @param numDaysToRotate How many days between each rotation
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.socialLeaderboard.postScoreToDynamicLeaderboardDays = function(leaderboardName, score,
        data, leaderboardType, rotationReset, retainedCount, numDaysToRotate, callback ) {
    brainCloudManager
            .sendRequest({
                service : brainCloudClient.SERVICE_LEADERBOARD,
                operation : brainCloudClient.socialLeaderboard.OPERATION_POST_SCORE_DYNAMIC,
                data : {
                    leaderboardId : leaderboardName,
                    score : score,
                    data : data,
                    leaderboardType : leaderboardType,
                    rotationType : "DAYS",
                    rotationResetTime : rotationReset.getTime().toFixed(0),
                    retainedCount : retainedCount,
                    numDaysToRotate : numDaysToRotate
                },
                callback : callback
            });
};

/**
* Retrieve the social leaderboard for a group.
*
* Service Name - leaderboard
* Service Operation - GET_GROUP_SOCIAL_LEADERBOARD
*
* @param leaderboardId The leaderboard to retreive
* @param groupId The ID of the group
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.socialLeaderboard.getGroupSocialLeaderboard = function(leaderboardId, groupId, callback) {
    var message = {
        leaderboardId : leaderboardId,
        groupId : groupId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_LEADERBOARD,
        operation : brainCloudClient.socialLeaderboard.OPERATION_GET_GROUP_SOCIAL_LEADERBOARD,
        data : message,
        callback : callback
    });
}

/**
* Retrieve the social leaderboard for a group.
*
* Service Name - leaderboard
* Service Operation - GET_GROUP_SOCIAL_LEADERBOARD
*
* @param leaderboardId The leaderboard to retrieve
* @param profileIds The IDs of the players
* @param callback The method to be invoked when the server response is received
*/
brainCloudClient.socialLeaderboard.getPlayersSocialLeaderboard = function(leaderboardId, profileIds, callback) {
    var message = {
        leaderboardId : leaderboardId,
        profileIds : profileIds
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_LEADERBOARD,
        operation : brainCloudClient.socialLeaderboard.OPERATION_GET_PLAYERS_SOCIAL_LEADERBOARD,
        data : message,
        callback : callback
    });
}

/**
 * Retrieve a list of all leaderboards
 *
 * Service Name - leaderboard
 * Service Operation - LIST_ALL_LEADERBOARDS
 *
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.socialLeaderboard.listAllLeaderboards = function(callback) {
    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_LEADERBOARD,
        operation : brainCloudClient.socialLeaderboard.OPERATION_LIST_ALL_LEADERBOARDS,
        data : null,
        callback : callback
    });
}

/**
 * Removes a player's score from the leaderboard
 *
 * Service Name - leaderboard
 * Service Operation - REMOVE_PLAYER_SCORE
 *
 * @param leaderboardId The leaderboard ID
 * @param versionId The version of the leaderboard. Use -1 to specifiy the currently active leaderboard version
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.socialLeaderboard.removePlayerScore = function(leaderboardId, versionId, callback) {
    var message = {
        leaderboardId : leaderboardId,
        versionId : versionId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_LEADERBOARD,
        operation : brainCloudClient.socialLeaderboard.OPERATION_REMOVE_PLAYER_SCORE,
        data : message,
        callback : callback
    });
}

/**
 * Gets a player's score from a leaderboard
 *
 * Service Name - leaderboard
 * Service Operation - GET_PLAYER_SCORE
 *
 * @param leaderboardId The leaderboard ID
 * @param versionId The version of the leaderboard. Use -1 for current.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.socialLeaderboard.getPlayerScore = function(leaderboardId, versionId, callback) {
    var message = {
        leaderboardId : leaderboardId,
        versionId : versionId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_LEADERBOARD,
        operation : brainCloudClient.socialLeaderboard.OPERATION_GET_PLAYER_SCORE,
        data : message,
        callback : callback
    });
}

/**
 * Gets a player's score from multiple leaderboards
 *
 * Service Name - leaderboard
 * Service Operation - GET_PLAYER_SCORES_FROM_LEADERBOARDS
 *
 * @param leaderboardIds A collection of leaderboardIds to retrieve scores from
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.socialLeaderboard.getPlayerScoresFromLeaderboards = function(leaderboardIds, callback) {
    var message = {
        leaderboardIds : leaderboardIds
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_LEADERBOARD,
        operation : brainCloudClient.socialLeaderboard.OPERATION_GET_PLAYER_SCORES_FROM_LEADERBOARDS,
        data : message,
        callback : callback
    });
}
brainCloudClient.statusCodes = {};

brainCloudClient.statusCodes.OK = 200;
brainCloudClient.statusCodes.FORBIDDEN = 403;
brainCloudClient.statusCodes.INTERNAL_SERVER_ERROR = 500;

brainCloudClient.statusCodes.CLIENT_NETWORK_ERROR = 900;
brainCloudClient.time = {};

brainCloudClient.SERVICE_TIME = "time";

brainCloudClient.time.OPERATION_READ = "READ";

/**
    * Method returns the server time in UTC. This is in UNIX millis time format.
    * For instance 1396378241893 represents 2014-04-01 2:50:41.893 in GMT-4.
    *
 * Service Name - Time
    * Service Operation - Read
    *
    * Server API reference: ServiceName.Time, ServiceOperation.Read
    *
    * @param callback The method to be invoked when the server response is received
    */
brainCloudClient.time.readServerTime = function(callback) {
    brainCloudManager.sendRequest({
        service: brainCloudClient.SERVICE_TIME,
        operation: brainCloudClient.time.OPERATION_READ,
        data: {

        },
        callback: callback
    });
};
brainCloudClient.tournament = {};

brainCloudClient.SERVICE_TOURNAMENT = "tournament";

brainCloudClient.tournament.OPERATION_CLAIM_TOURNAMENT_REWARD = "CLAIM_TOURNAMENT_REWARD";
brainCloudClient.tournament.OPERATION_GET_TOURNAMENT_STATUS = "GET_TOURNAMENT_STATUS";
brainCloudClient.tournament.OPERATION_JOIN_TOURNAMENT = "JOIN_TOURNAMENT";
brainCloudClient.tournament.OPERATION_LEAVE_TOURNAMENT = "LEAVE_TOURNAMENT";
brainCloudClient.tournament.OPERATION_POST_TOURNAMENT_SCORE = "POST_TOURNAMENT_SCORE";
brainCloudClient.tournament.OPERATION_POST_TOURNAMENT_SCORE_WITH_RESULTS = "POST_TOURNAMENT_SCORE_WITH_RESULTS";
brainCloudClient.tournament.OPERATION_VIEW_CURRENT_REWARD = "VIEW_CURRENT_REWARD";
brainCloudClient.tournament.OPERATION_VIEW_REWARD = "VIEW_REWARD";

/**
 * Processes any outstanding rewards for the given player
 *
 * Service Name - tournament
 * Service Operation - CLAIM_TOURNAMENT_REWARD
 *
 * @param leaderboardId The leaderboard for the tournament
 * @param versionId Version of the tournament. Use -1 for the latest version.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.tournament.claimTournamentReward = function(leaderboardId, versionId, callback) {
    var message = {
        leaderboardId : leaderboardId,
        versionId : versionId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_TOURNAMENT,
        operation : brainCloudClient.tournament.OPERATION_CLAIM_TOURNAMENT_REWARD,
        data : message,
        callback : callback
    });
};

/**
 * Get tournament status associated with a leaderboard
 *
 * Service Name - tournament
 * Service Operation - GET_TOURNAMENT_STATUS
 *
 * @param leaderboardId The leaderboard for the tournament
 * @param versionId Version of the tournament. Use -1 for the latest version.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.tournament.getTournamentStatus = function(leaderboardId, versionId, callback) {
    var message = {
        leaderboardId : leaderboardId,
        versionId : versionId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_TOURNAMENT,
        operation : brainCloudClient.tournament.OPERATION_GET_TOURNAMENT_STATUS,
        data : message,
        callback : callback
    });
};

/**
 * Join the specified tournament.
 * Any entry fees will be automatically collected.
 *
 * Service Name - tournament
 * Service Operation - JOIN_TOURNAMENT
 *
 * @param leaderboardId The leaderboard for the tournament
 * @param tournamentCode Tournament to join
 * @param initialScore Initial score for the user
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.tournament.joinTournament = function(leaderboardId, tournamentCode, initialScore, callback) {
    var message = {
        leaderboardId : leaderboardId,
        tournamentCode : tournamentCode,
        initialScore : initialScore
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_TOURNAMENT,
        operation : brainCloudClient.tournament.OPERATION_JOIN_TOURNAMENT,
        data : message,
        callback : callback
    });
};

/**
 * Removes player's score from tournament leaderboard
 *
 * Service Name - tournament
 * Service Operation - LEAVE_TOURNAMENT
 *
 * @param leaderboardId The leaderboard for the tournament
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.tournament.leaveTournament = function(leaderboardId, callback) {
    var message = {
        leaderboardId : leaderboardId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_TOURNAMENT,
        operation : brainCloudClient.tournament.OPERATION_LEAVE_TOURNAMENT,
        data : message,
        callback : callback
    });
};

/**
 * Post the users score to the leaderboard
 *
 * Service Name - tournament
 * Service Operation - POST_TOURNAMENT_SCORE
 *
 * @param leaderboardId The leaderboard for the tournament
 * @param score The score to post
 * @param data Optional data attached to the leaderboard entry
 * @param roundStartedTime Time the user started the match resulting in the score being posted in UTC.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.tournament.postTournamentScore = function(leaderboardId, score, data, roundStartedTime, callback) {
    var message = {
        leaderboardId : leaderboardId,
        score : score,
        roundStartedEpoch: roundStartedTime.getTime()
    };

    if(data) message.data = data;

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_TOURNAMENT,
        operation : brainCloudClient.tournament.OPERATION_POST_TOURNAMENT_SCORE,
        data : message,
        callback : callback
    });
};

/**
 * Post the users score to the leaderboard
 *
 * Service Name - tournament
 * Service Operation - POST_TOURNAMENT_SCORE_WITH_RESULTS
 *
 * @param leaderboardId The leaderboard for the tournament
 * @param score The score to post
 * @param data Optional data attached to the leaderboard entry
 * @param roundStartedTime Time the user started the match resulting in the score being posted in UTC.
 * @param sort Sort key Sort order of page.
 * @param beforeCount The count of number of players before the current player to include.
 * @param afterCount The count of number of players after the current player to include.
 * @param initialScore The initial score for players first joining a tournament
 *						  Usually 0, unless leaderboard is LOW_VALUE
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.tournament.postTournamentScoreWithResults = function(
    leaderboardId,
    score,
    data,
    roundStartedTime,
    sort,
    beforeCount,
    afterCount,
    initialScore,
    callback) {
    var message = {
        leaderboardId : leaderboardId,
        score : score,
        roundStartedEpoch: roundStartedTime.getTime(),
        sort: sort,
        beforeCount : beforeCount,
        afterCount : afterCount,
        initialScore : initialScore
    };

    if(data) message.data = data;

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_TOURNAMENT,
        operation : brainCloudClient.tournament.OPERATION_POST_TOURNAMENT_SCORE_WITH_RESULTS,
        data : message,
        callback : callback
    });
};

/**
 * Returns the user's expected reward based on the current scores
 *
 * Service Name - tournament
 * Service Operation - VIEW_CURRENT_REWARD
 *
 * @param leaderboardId The leaderboard for the tournament
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.tournament.viewCurrentReward = function(leaderboardId, callback) {
    var message = {
        leaderboardId : leaderboardId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_TOURNAMENT,
        operation : brainCloudClient.tournament.OPERATION_VIEW_CURRENT_REWARD,
        data : message,
        callback : callback
    });
};

/**
 * Returns the user's reward from a finished tournament
 *
 * Service Name - tournament
 * Service Operation - VIEW_REWARD
 *
 * @param leaderboardId The leaderboard for the tournament
 * @param versionId Version of the tournament. Use -1 for the latest version.
 * @param callback The method to be invoked when the server response is received
 */
brainCloudClient.tournament.viewReward = function(leaderboardId, versionId, callback) {
    var message = {
        leaderboardId : leaderboardId,
        versionId : versionId
    };

    brainCloudManager.sendRequest({
        service : brainCloudClient.SERVICE_TOURNAMENT,
        operation : brainCloudClient.tournament.OPERATION_VIEW_REWARD,
        data : message,
        callback : callback
    });
};
/**
 * The BrainCloudWrapper provides some convenience functionality to developers when they are
 * getting started with the authentication system. 
 *
 * By using the wrapper authentication methods, the anonymous and profile ids will be automatically 
 * persisted upon successful authentication. When authenticating, any stored anonymous/profile ids will
 * be sent to the server. This strategy is useful when using anonymous authentication.
 */

(function(brainCloudWrapper, undefined) {
    
    /////////////////////////////////////////////////////////////////////////// 
    // private members/methods
    ///////////////////////////////////////////////////////////////////////////

    var _alwaysAllowProfileSwitch = true;
    
    var _initializeIdentity = function(isAnonymousAuth) {
        var profileId = brainCloudWrapper.getStoredProfileId();
        var anonymousId = brainCloudWrapper.getStoredAnonymousId();
        if (profileId == null) {
            profileId = "";
        }
        if (anonymousId == null) {
            anonymousId = "";
        }
            
        // create an anonymous ID if necessary
        if (anonymousId == "" || profileId == "")
        {
            anonymousId = brainCloudClient.authentication.generateAnonymousId();
            profileId = "";
            brainCloudWrapper.setStoredAnonymousId(anonymousId);
            brainCloudWrapper.setStoredProfileId(profileId);
        }
        
        var profileIdToAuthenticateWith = profileId;
        if (!isAnonymousAuth && _alwaysAllowProfileSwitch)
        {
            profileIdToAuthenticateWith = "";
        }
        //setStoredAuthenticationType(isAnonymousAuth ? AUTHENTICATION_ANONYMOUS : "");
        
        // send our IDs to brainCloudClient
        brainCloudClient.initializeIdentity(profileIdToAuthenticateWith, anonymousId);
    };
    
    var _authResponseHandler = function(result) {
        if (result.status == 200) {
            var profileId = result.data.profileId;
            brainCloudWrapper.setStoredProfileId(profileId);
        }
    };
    
    ///////////////////////////////////////////////////////////////////////////
    // public members/methods
    ///////////////////////////////////////////////////////////////////////////

    brainCloudWrapper.initialize = function(appId, secret, appVersion) {
        brainCloudClient.initialize(appId, secret, appVersion);
    };
    
    brainCloudWrapper.getStoredAnonymousId = function() {
        return localStorage.getItem("anonymousId");
    };

    brainCloudWrapper.setStoredAnonymousId = function(anonymousId) {
        localStorage.setItem("anonymousId", anonymousId);
    };

    brainCloudWrapper.resetStoredAnonymousId = function() {
        brainCloudWrapper.setStoredAnonymousId("");
    };

    brainCloudWrapper.getStoredProfileId = function() {
        return localStorage.getItem("profileId");
    };

    brainCloudWrapper.setStoredProfileId = function(profileId) {
        localStorage.setItem("profileId", profileId);
    };

    brainCloudWrapper.resetStoredProfileId = function() {
        brainCloudWrapper.setStoredProfileId("");
    };

    brainCloudWrapper.getAlwaysAllowProfileSwitch = function() {
        return _alwaysAllowProfileSwitch;
    };

    brainCloudWrapper.setAlwaysAllowProfileSwitch = function(alwaysAllow) {
        _alwaysAllowProfileSwitch = alwaysAllow;
    };
    
    /**
     * Authenticate a user anonymously with brainCloud - used for apps that don't want to bother
     * the user to login, or for users who are sensitive to their privacy
     *
     * Service Name - authenticationV2
     * Service Operation - AUTHENTICATE
     *
     * @param responseHandler {function} - The user callback method
     *
     */
    brainCloudWrapper.authenticateAnonymous = function(responseHandler) {

        _initializeIdentity(true);
        
        brainCloudClient.authentication.authenticateAnonymous(
            true,
            function(result) {
                _authResponseHandler(result);
                responseHandler(result);
            });
    };

    /**
     * Authenticate the user with a custom Email and Password. Note that the client app
     * is responsible for collecting and storing the e-mail and potentially password
     * (for convenience) in the client data. For the greatest security,
     * force the user to re-enter their password at each login
     * (or at least give them that option).
     * 
     * Service Name - authenticationV2
     * Service Operation - AUTHENTICATE
     * 
     * @param email {string} - The e-mail address of the user
     * @param password {string} - The password of the user
     * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
     * @param responseHandler {function} - The user callback method
     */
    brainCloudWrapper.authenticateEmailPassword = function(email, password, forceCreate, responseHandler) {

        _initializeIdentity(true);
        
        brainCloudClient.authentication.authenticateEmailPassword(
            email,
            password, 
            forceCreate,
            function(result) {
                _authResponseHandler(result);
                responseHandler(result);
            });
    };

    /**
     * Authenticate the user via cloud code (which in turn validates the supplied credentials against an external system).
     * This allows the developer to extend brainCloud authentication to support other backend authentication systems. 
     *
     * Service Name - authenticationV2
     * Service Operation - AUTHENTICATE
     * 
     * @param userId {string} - The userId
     * @param token {string} - The user token (password etc) 
     * @param externalAuthName {string} - The name of the cloud script to call for external authentication
     * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
     * @param responseHandler {function} - The user callback method
     */
    brainCloudWrapper.authenticateExternal = function(userId, token, externalAuthName, forceCreate, responseHandler) {

        _initializeIdentity(true);
        
        brainCloudClient.authentication.authenticateExternal(
            userId,
            token,
            externalAuthName,
            forceCreate,
            function(result) {
                _authResponseHandler(result);
                responseHandler(result);
            });
    };

    /**
     * Authenticate the user with brainCloud using their Facebook Credentials
     * 
     * Service Name - authenticationV2
     * Service Operation - AUTHENTICATE
     * 
     * @param facebookId {string} - The Facebook id of the user
     * @param facebookToken {string} - The validated token from the Facebook SDK
     * (that will be further validated when sent to the bC service)
     * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
     * @param responseHandler {function} - The user callback method
     */
    brainCloudWrapper.authenticateFacebook = function(facebookId, facebookToken, forceCreate, responseHandler) {

        _initializeIdentity(true);
        
        brainCloudClient.authentication.authenticateFacebook(
            facebookId,
            facebookToken,
            forceCreate,
            function(result) {
                _authResponseHandler(result);
                responseHandler(result);
            });
    };

    /**
     * Authenticate the user using their Game Center id
     * 
     * Service Name - authenticationV2
     * Service Operation - AUTHENTICATE
     * 
     * @param gameCenterId {string} - The player's game center id 
                                    (use the playerID property from the local GKPlayer object)
     * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
     * @param responseHandler {function} - The user callback method
     */
    brainCloudWrapper.authenticateGameCenter = function(gameCenterId, forceCreate, responseHandler) {

        _initializeIdentity(true);
        
        brainCloudClient.authentication.authenticateGameCenter(
            gameCenterId,
            forceCreate,
            function(result) {
                _authResponseHandler(result);
                responseHandler(result);
            });
    };

    /**
     * Authenticate the user using a google user id (email address) and google authentication token.
     * 
     * Service Name - authenticationV2
     * Service Operation - AUTHENTICATE
     * 
     * @param googleId {string} - String representation of google+ userid (email)
     * @param googleToken {string} - The authentication token derived via the google apis.
     * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
     * If set to false, you need to handle errors in the case of new users.
     * @param responseHandler {function} - The user callback method
     */
    brainCloudWrapper.authenticateGoogle = function(googleId, googleToken, forceCreate, responseHandler) {

        _initializeIdentity(true);
        
        brainCloudClient.authentication.authenticateGoogle(
            googleId,
            googleToken,
            forceCreate,
            function(result) {
                _authResponseHandler(result);
                responseHandler(result);
            });
    };


    /**
     * Authenticate the user using a steam userId and session ticket (without any validation on the userId).
     *
     * Service Name - authenticationV2
     * Service Operation - AUTHENTICATE
     *
     * @param userid  String representation of 64 bit steam id
     * @param sessionticket  The session ticket of the user (hex encoded)
     * @param forceCreate Should a new profile be created for this user if the account does not exist?
     * @param callback The method to be invoked when the server response is received
     *
     * @returns   performs the in_success callback on success, in_failure callback on failure
     *
     */
    brainCloudWrapper.authenticateSteam = function(userId, sessionTicket, forceCreate, responseHandler) {

        _initializeIdentity(true);
        
        brainCloudClient.authentication.authenticateSteam(
            userId,
            sessionTicket,
            forceCreate,
            function(result) {
                _authResponseHandler(result);
                responseHandler(result);
            });
    };
    
    /**
     * Authenticate the user using a Twitter user ID, authentication token, and secret from Twitter
     * 
     * Service Name - authenticationV2
     * Service Operation - AUTHENTICATE
     * 
     * @param userId {string} - String representation of Twitter user ID
     * @param token {string} - The authentication token derived via the Twitter APIs
     * @param secret {string} - The secret given when attempting to link with Twitter
     * @param forceCreate {boolean} - Should a new profile be created for this user if the account does not exist?
     * If set to false, you need to handle errors in the case of new users.
     * @param responseHandler {function} - The user callback method
     */
    brainCloudWrapper.authenticateTwitter = function(userId, token, secret, forceCreate, responseHandler) {

        _initializeIdentity(true);
        
        brainCloudClient.authentication.authenticateTwitter(
            userId,
            token,
            secret,
            forceCreate,
            function(result) {
                _authResponseHandler(result);
                responseHandler(result);
            });
    };

    /** Method authenticates the user using universal credentials
     * 
     * Service Name - authenticationV2
     * Service Operation - AUTHENTICATE
     * 
     * @param userId {string} - The user's id. Can be any string you want.
     * @param userPassword {string} - The user's password. Can be any string you want.
     * @param forceCreate {boolean} - True if we force creation of the user if they do not already exist.
     * If set to false, you need to handle errors in the case of new users.
     * @param responseHandler {function} - The user callback method
     */
    brainCloudWrapper.authenticateUniversal = function(userId, userPassword, forceCreate, responseHandler) {

        _initializeIdentity(true);
        
        brainCloudClient.authentication.authenticateUniversal(
            userId,
            userPassword,
            forceCreate,
            function(result) {
                _authResponseHandler(result);
                responseHandler(result);
            });
    };

    /** Method authenticates the user using universal credentials
     * 
     * @param responseHandler {function} - The user callback method
     */
    brainCloudWrapper.reconnect = function(responseHandler) {
        brainCloudWrapper.authenticateAnonymous(responseHandler); 
    };
    
}(window.brainCloudWrapper = window.brainCloudWrapper || {}));
